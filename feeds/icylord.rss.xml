<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>icylord's blog</title><link>http://icylord.github.io/</link><description></description><atom:link href="http://icylord.github.io/feeds/icylord.rss.xml" rel="self"></atom:link><lastBuildDate>Sun, 12 Oct 2014 00:00:00 +0200</lastBuildDate><item><title>CPP Api Design Reading Notes 1 : Design Pattern</title><link>http://icylord.github.io/cpp-api-design-reading-notes-1-design-pattern.html</link><description>&lt;h1&gt;PIMPL IDIOM&lt;/h1&gt;
&lt;p&gt;Pointer to implemetation : as a way to avoid exposing private details in your header files.&lt;/p&gt;
&lt;p&gt;So, how much logic to locate in the Impl class ?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Private member variables and methods. Lets you maintain the encapsulation of data and methods that acts on those data and lets you avoiding declearing private methods in the public header files.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Copy Sematics&lt;/h2&gt;
&lt;p&gt;Impl* only does shallow copy.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;make your class uncopyable.&lt;/li&gt;
&lt;li&gt;explicitly define the copy sematics.&lt;/li&gt;
&lt;li&gt;use scoped_ptr to hold Impl*&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Advantages of PIMPL&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Information hiding&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define private public&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;yourapi.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#undef private&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Reduced coupling&lt;/li&gt;
&lt;li&gt;Faster compiles&lt;/li&gt;
&lt;li&gt;Greater binary compatibility&lt;/li&gt;
&lt;li&gt;Lazy allocation&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sun, 12 Oct 2014 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2014-10-12:cpp-api-design-reading-notes-1-design-pattern.html</guid><category>C++</category></item><item><title>CPP Api Design Reading Notes 2 : Design Pattern</title><link>http://icylord.github.io/cpp-api-design-reading-notes-2-design-pattern.html</link><description>&lt;h1&gt;Singleton&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;ensure that a class only ever has one instance.&lt;/li&gt;
&lt;li&gt;also privades a global pointer of access to that single instance.&lt;/li&gt;
&lt;li&gt;a singleton as a more elegant global var.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Several advantages&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Enforce that only one instance of that class.&lt;/li&gt;
&lt;li&gt;Provides control over the allocation and deseruction of the object.&lt;/li&gt;
&lt;li&gt;Allows support for thread-safe access to the object's global state.&lt;/li&gt;
&lt;li&gt;Avoids polluting the global namespace &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Singleton&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;get_instance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;
    &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Thread-safe issue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;locking on get_instance();&lt;/li&gt;
&lt;li&gt;avoiding lazy instatiation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(1) Static intialization&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get_instance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(2) Explicit API intialization&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sun, 12 Oct 2014 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2014-10-12:cpp-api-design-reading-notes-2-design-pattern.html</guid><category>C++</category></item><item><title>CPP Api Design Reading Notes 3 : Design Pattern</title><link>http://icylord.github.io/cpp-api-design-reading-notes-3-design-pattern.html</link><description>&lt;h1&gt;Factory methods&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Create objects without having to specify&lt;/li&gt;
&lt;li&gt;a generalization of a constructor&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Limitations of C++ constructors&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;No return result.&lt;/li&gt;
&lt;li&gt;Constrained naming.&lt;/li&gt;
&lt;li&gt;Statically bound creation.&lt;/li&gt;
&lt;li&gt;No virtual constuctors.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Simple Factory&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Factory&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Factory&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CreateSomething&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;some_type&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Drawbacks&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;it contains hardcoded knowledge of the avaliable derived classes&lt;/li&gt;
&lt;li&gt;users can not add new rendered to the systems.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Extensible Factory Example&lt;/h2&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sun, 12 Oct 2014 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2014-10-12:cpp-api-design-reading-notes-3-design-pattern.html</guid><category>C++</category></item><item><title>Shell study notes</title><link>http://icylord.github.io/shell-study-notes.html</link><description>&lt;h1&gt;Shell 学习笔记&lt;/h1&gt;
&lt;h2&gt;开始&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello World !&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;"#!"" 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。echo命令用于向窗口输出文本。&lt;/p&gt;
&lt;p&gt;运行Shell脚本&lt;/p&gt;
&lt;p&gt;作为可执行程序  chmod a+x xxx.sh ./xxx.sh&lt;/p&gt;
&lt;p&gt;使用 read 命令从 stdin 获取输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;What is your name?&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="n"&gt;PERSON&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello, $PERSON&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;定义变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;定义变量时，变量名不加美元符号（$)，量名和等号之间不能有空格。&lt;/li&gt;
&lt;li&gt;首个字符必须为字母（a-z，A-Z）。&lt;/li&gt;
&lt;li&gt;中间不能有空格，可以使用下划线（_）。&lt;/li&gt;
&lt;li&gt;不能使用标点符号。&lt;/li&gt;
&lt;li&gt;不能使用bash里的关键字（可用help命令查看保留关键字）。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;variableName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;value&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;使用变量&lt;/h2&gt;
&lt;p&gt;使用一个定义过的变量，只要在变量名前面加美元符号（$）即可，变量名外面的花括号是可选的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;your_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mozhiyan&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;your_name&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;your_name&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;myUrl&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;xxx&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;readonly&lt;/span&gt; &lt;span class="n"&gt;myUrl&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用 unset 命令可以删除变量&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;myUrl&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;xxx&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;unset&lt;/span&gt; &lt;span class="n"&gt;myUrl&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Shell特殊变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;$0 当前脚本的文件名&lt;/li&gt;
&lt;li&gt;$n 传递给脚本或函数的参数。n是一个数字，表示第几个参数。例如，第一个参数是$1&lt;/li&gt;
&lt;li&gt;$# 传递给脚本或函数的参数个数。&lt;/li&gt;
&lt;li&gt;$* 传递给脚本或函数的所有参数。&lt;/li&gt;
&lt;li&gt;$@ 传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同。&lt;/li&gt;
&lt;li&gt;$? 上个命令的退出状态，或函数的返回值。&lt;/li&gt;
&lt;li&gt;$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;File Name: $0&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;First Parameter : $1&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;First Parameter : $2&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Quoted Values: $@&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Quoted Values: $*&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Total Number of Parameters : $#&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;命令替换&lt;/h2&gt;
&lt;p&gt;命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。&lt;/p&gt;
&lt;p&gt;命令替换的语法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;变量替换&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;${var}   变量本来的值&lt;/li&gt;
&lt;li&gt;${var:-word} 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。&lt;/li&gt;
&lt;li&gt;${var:=word} 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。&lt;/li&gt;
&lt;li&gt;${var:?message}  如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。&lt;/li&gt;
&lt;li&gt;${var:+word} 如果变量 var 被定义，那么返回 word，但不改变 var 的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Shell运算符&lt;/h2&gt;
&lt;p&gt;Bash 支持很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。&lt;/p&gt;
&lt;p&gt;expr 是一款表达式计算工具，使用它能完成表达式的求值操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;``cpp
val=&lt;/code&gt;expr 2 + 2`
echo "Total value : $val"&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;两点注意：&lt;/span&gt;

 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="err"&gt;表达式和运算符之间要有空格，例如&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="err"&gt;是不对的，必须写成&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;，这与我们熟悉的大多数编程语言不一样。&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="err"&gt;完整的表达式要被&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="err"&gt;包含，注意这个字符不是常用的单引号，在&lt;/span&gt; &lt;span class="n"&gt;Esc&lt;/span&gt; &lt;span class="err"&gt;键下边。&lt;/span&gt;

 &lt;span class="err"&gt;例子：&lt;/span&gt;
  &lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;
&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;a + b : $val&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;a - b : $val&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;a * b : $val&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;b / a : $val&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;b % a : $val&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;then&lt;/span&gt;
   &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;a is equal to b&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;then&lt;/span&gt;
   &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;a is not equal to b&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;算术运算符列表&lt;/h2&gt;
&lt;h3&gt;运算符  说明  举例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;"+"  加法  &lt;code&gt;expr $a + $b&lt;/code&gt; 结果为 30。&lt;/li&gt;
&lt;li&gt;"-"  减法  &lt;code&gt;expr $a - $b&lt;/code&gt; 结果为 10。&lt;/li&gt;
&lt;li&gt;"*"  乘法  &lt;code&gt;expr $a \* $b&lt;/code&gt; 结果为  200。&lt;/li&gt;
&lt;li&gt;"/"  除法  &lt;code&gt;expr $b / $a&lt;/code&gt; 结果为 2。&lt;/li&gt;
&lt;li&gt;"%"  取余  &lt;code&gt;expr $b % $a&lt;/code&gt; 结果为 0。&lt;/li&gt;
&lt;li&gt;"="  赋值  a=$b 将把变量 b 的值赋给 a。&lt;/li&gt;
&lt;li&gt;"==" 相等。用于比较两个数字，相同则返回 true。[ $a == $b ] 返回 false。&lt;/li&gt;
&lt;li&gt;"!="     不相等。用于比较两个数字，不相同则返回 true。[ $a != $b ] 返回 true。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Shell字符串&lt;/h2&gt;
&lt;p&gt;单引号
 ```cpp
str='this is a string'&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;双引号&lt;/span&gt;
 &lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;
&lt;span class="n"&gt;your_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;qinjx&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello, I know your are &lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;$your_name&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;! &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获取字符串长度
 ```cpp
string="abcd"
echo ${#string} #输出 4&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;提取子字符串
 ```cpp
string=&amp;quot;alibaba is a great company&amp;quot;
echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; #输出liba
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;字符串截取相关&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;${parameter%word} 最小限度从后面截取word，用途是从右边开始删除第一次出现子字符串即其右边字符，保留左边字符，用法为%substr*&lt;/li&gt;
&lt;li&gt;${parameter%%word} 最大限度从后面截取word，用途是从右边开始删除最后一次出现子字符串即其右边字符，保留左边字符，用法为%%substr*&lt;/li&gt;
&lt;li&gt;${parameter#word} 最小限度从前面截取word，用途是从左边开始删除第一次出现子字符串即其左边字符，保留右边字符，用法为"#*substr"&lt;/li&gt;
&lt;li&gt;${parameter##word} 最大限度从前面截取word，用途是从左边开始删除最后一次出现子字符串即其左边字符，保留右边字符，用法为""##*substr"&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Shell if else语句&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;if ... fi 语句；&lt;/li&gt;
&lt;li&gt;if ... else ... fi 语句；&lt;/li&gt;
&lt;li&gt;if ... elif ... else ... fi 语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;if ... else 语句的语法：
 ```cpp
if [ expression ]
then
    Statement(s) to be executed if expression is true
fi&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;fi&lt;/span&gt; &lt;span class="err"&gt;语句的语法：&lt;/span&gt;
 &lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;then&lt;/span&gt; 
    &lt;span class="n"&gt;Statement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;executed&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="n"&gt;Statement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;executed&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;
&lt;span class="n"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;if ... elif ... fi 语句
  ```cpp
if [ expression ]
then 
    Statement(s) to be executed if expression is true
elif
then
    Statement(s) to be executed if expression is false
elif
then
    XXX
else
then 
    XXX
fi&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;## Shell for循环&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="err"&gt;循环一般格式为：&lt;/span&gt;
&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="err"&gt;变量&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="err"&gt;列表&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;command1&lt;/span&gt;
    &lt;span class="n"&gt;command2&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;commandN&lt;/span&gt;
&lt;span class="n"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例子，列出当前文件目录的png&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;png&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt; 
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sun, 12 Oct 2014 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2014-10-12:shell-study-notes.html</guid><category>Shell</category></item><item><title>libx264 x264_param_t</title><link>http://icylord.github.io/libx264-x264_param_t.html</link><description>&lt;h2&gt;libx264 x264_param_t&lt;/h2&gt;
&lt;h3&gt;转一个别人写好的libx264参数结构体x264_param_t的参数解析&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* 结构体x264_param_t定义在x264.h中 */&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;x264_param_t&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* CPU 标志位 */&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_threads&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 并行编码多帧; 线程数，为0则自动多线程编码&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_sliced_threads&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 如果为false，则一个slice只编码成一个NALU;&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 否则有几个线程，在编码成几个NALU。缺省为true。&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_deterministic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 是否允许非确定性时线程优化&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_cpu_independent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 强制采用典型行为，而不是采用独立于cpu的优化算法&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_sync_lookahead&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 线程超前缓存帧数&lt;/span&gt;

    &lt;span class="cm"&gt;/* 视频属性 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_width&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 视频图像的宽&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_height&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 视频图像的高&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_csp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                     &lt;span class="c1"&gt;// 编码比特流的CSP，仅支持i420，色彩空间设置&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_level_idc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 指明作用的level值，可能与编码复杂度有关&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_frame_total&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 编码帧的总数, 默认 0&lt;/span&gt;

    &lt;span class="cm"&gt;/* hrd : hypothetical reference decoder (假定参考解码器) , 检验编码器产生的符合&lt;/span&gt;
&lt;span class="cm"&gt;      该标准的NAL单元流或字节流的偏差值。蓝光视频、电视广播及其它特殊领域有此要求 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_nal_hrd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* vui参数集 : 视频可用性信息、视频标准化选项 */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* 宽高比的两个值相对互素，且在(0,  65535] 之间 */&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_sar_height&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 样本宽高比的高度&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_sar_width&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 样本宽高比的宽度&lt;/span&gt;

    &lt;span class="cm"&gt;/* 0=undef, 1=no overscan, 2=overscan 过扫描线，&lt;/span&gt;
&lt;span class="cm"&gt;        默认&amp;quot;undef&amp;quot;(不设置)，可选项：show(观看) / crop(去除) */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_overscan&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 以下的值可以参见H264附录E */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_vidformat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 视频在编码/数字化之前是什么类型，默认&amp;quot;undef&amp;quot;.&lt;/span&gt;
                                &lt;span class="c1"&gt;// 取值有：Component, PAL, NTSC, SECAM, MAC 等&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_fullrange&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 样本亮度和色度的计算方式，默认&amp;quot;off&amp;quot;，可选项：off/on&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_colorprim&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 原始色度格式，默认&amp;quot;undef&amp;quot;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_transfer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 转换方式，默认&amp;quot;undef&amp;quot;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_colmatrix&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 设置从RGB计算得到亮度和色度所用的矩阵系数，默认&amp;quot;undef&amp;quot;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_chroma_loc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 设置色度采样位置，范围0~5，默认0&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;vui&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 比特流参数 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_frame_reference&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 最大参考帧数目&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_dpb_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// Decoded picture buffer size&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_keyint_max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 设定IDR帧之间的最间隔，在此间隔设置IDR关键帧&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_keyint_min&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 设定IDR帧之间的最小间隔, 场景切换小于此值编码位I帧, 而不是 IDR帧.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_scenecut_threshold&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 场景切换阈值，插入I帧&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_intra_refresh&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 是否使用周期帧内刷新替代IDR帧&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_bframe&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 两个参考帧之间的B帧数目&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_bframe_adaptive&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 自适应B帧判定, 可选取值：X264_B_ADAPT_FAST等&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_bframe_bias&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 控制B帧替代P帧的概率，范围-100 ~ +100，&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 该值越高越容易插入B帧，默认0.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_bframe_pyramid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 允许部分B帧为参考帧，&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 可选取值：0=off,  1=strict hierarchical,  2=normal&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_open_gop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// Close GOP是指帧间的预测都是在GOP中进行的。&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 使用Open GOP，后一个GOP会参考前一个GOP的信息。&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_bluray_compat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 支持蓝光碟&lt;/span&gt;

    &lt;span class="cm"&gt;/* 去块滤波器需要的参数, alpha和beta是去块滤波器参数 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_deblocking_filter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 去块滤波开关&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_deblocking_filter_alphac0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// [-6, 6] -6 light filter, 6 strong&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_deblocking_filter_beta&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// [-6, 6] 同上&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_cabac&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// 自适应算术编码cabac开关&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_cabac_init_idc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 给出算术编码初始化时表格的选择&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_interlaced&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 隔行扫描&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_constrained_intra&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

     &lt;span class="cm"&gt;/* 量化 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_cqm_preset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 自定义量化矩阵(CQM), 初始化量化模式为flat&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz_cqm_file&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 读取JM格式的外部量化矩阵文件，忽略其他cqm选项&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_4iy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;           &lt;span class="c1"&gt;// used only if i_cqm_preset == X264_CQM_CUSTOM   &lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_4py&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_4ic&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_4pc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_8iy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_8py&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_8ic&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_8pc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="cm"&gt;/* 日志 */&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pf_log&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i_level&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;va_list&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// 日志函数&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt;  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p_log_private&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;    &lt;span class="n"&gt;i_log_level&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 日志级别，不需要打印编码信息时直接注释掉即可&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;    &lt;span class="n"&gt;b_visualize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 是否显示日志&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt;   &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz_dump_yuv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;//  重建帧的文件名&lt;/span&gt;

    &lt;span class="cm"&gt;/* 编码分析参数 */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;intra&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;//  帧内分区&lt;/span&gt;
        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;inter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;//  帧间分区&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_transform_8x8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// &lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_weighted_pred&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// P帧权重&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_weighted_bipred&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// B帧隐式加权&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_direct_mv_pred&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 时间空间运动向量预测模式&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_chroma_qp_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 色度量化步长偏移量&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_me_method&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 运动估计算法 (X264_ME_*)&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_me_range&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 整像素运动估计搜索范围 (from predicted mv) &lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_mv_range&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 运动矢量最大长度. -1 = auto, based on level&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_mv_range_thread&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 线程之间的最小运动向量缓冲.  -1 = auto, based on number of threads.&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_subpel_refine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 亚像素运动估计质量&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_chroma_me&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 亚像素色度运动估计和P帧的模式选择&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_mixed_references&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 允许每个宏块的分区有它自己的参考号&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_trellis&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// Trellis量化提高效率，对每个8x8的块寻找合适的量化值，需要CABAC，&lt;/span&gt;
                                        &lt;span class="c1"&gt;// 0 ：即关闭  1：只在最后编码时使用  2：在所有模式决策上启用&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_fast_pskip&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 快速P帧跳过检测&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_dct_decimate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// P帧变换系数阈值&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_noise_reduction&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 自适应伪盲区&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_psy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                     &lt;span class="c1"&gt;// Psy优化开关，可能会增强细节&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_psy_rd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// Psy RD强度&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_psy_trellis&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// Psy Trellis强度&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_luma_deadzone&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;        &lt;span class="c1"&gt;// 亮度量化中使用的盲区大小，{ 帧间, 帧内 }&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_psnr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// 计算和打印PSNR信息&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_ssim&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// 计算和打印SSIM信息&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;analyse&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 码率控制参数 */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_rc_method&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 码率控制方式 ： X264_RC_CQP恒定质量,  &lt;/span&gt;
                                        &lt;span class="c1"&gt;// X264_RC_CRF恒定码率,  X264_RC_ABR平均码率&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_qp_constant&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 指定P帧的量化值，0 - 51，0表示无损&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_qp_min&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 允许的最小量化值，默认10&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_qp_max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 允许的最大量化值，默认51&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_qp_step&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 量化步长，即相邻两帧之间量化值之差的最大值&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;i_bitrate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 平均码率大小&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_rf_constant&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 1pass VBR, nominal QP. 实际质量，值越大图像越花,越小越清晰&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_rf_constant_max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 最大码率因子，该选项仅在使用CRF并开启VBV时有效，&lt;/span&gt;
                                        &lt;span class="c1"&gt;// 图像质量的最大值，可能会导致VBV下溢。&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_rate_tolerance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 允许的误差&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;    &lt;span class="n"&gt;i_vbv_max_bitrate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 平均码率模式下，最大瞬时码率，默认0&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;    &lt;span class="n"&gt;i_vbv_buffer_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 码率控制缓冲区的大小，单位kbit，默认0&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_vbv_buffer_init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 设置码率控制缓冲区（VBV）缓冲达到多满(百分比)，才开始回放，&lt;/span&gt;
                                        &lt;span class="c1"&gt;// 范围0~1.0，默认0.9&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_ip_factor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// I帧和P帧之间的量化因子（QP）比值，默认1.4&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_pb_factor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// P帧和B帧之间的量化因子（QP）比值，默认1.3&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;i_aq_mode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 自适应量化（AQ）模式。 0：关闭AQ  &lt;/span&gt;
                                        &lt;span class="c1"&gt;// 1：允许AQ在整个视频中和帧内重新分配码&lt;/span&gt;
                                        &lt;span class="c1"&gt;// 2：自方差AQ(实验阶段)，尝试逐帧调整强度&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_aq_strength&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// AQ强度，减少平趟和纹理区域的块效应和模糊度&lt;/span&gt;

        &lt;span class="cm"&gt;/* MBTree File是一个临时文件，记录了每个P帧中每个MB被参考的情况。&lt;/span&gt;
&lt;span class="cm"&gt;          目前mbtree只处理P帧的MB，同时也不支持b_pyramid. */&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;b_mb_tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 是否开启基于macroblock的qp控制方法&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;i_lookahead&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 决定mbtree向前预测的帧数&lt;/span&gt;

        &lt;span class="cm"&gt;/* 2pass */&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;b_stat_write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 是否将统计数据写入到文件psz_stat_out中&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt;  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz_stat_out&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 输出文件用于保存第一次编码统计数据&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;b_stat_read&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 是否从文件psz_stat_in中读入统计数据&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt;  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz_stat_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 输入文件存有第一次编码的统计数据&lt;/span&gt;

        &lt;span class="cm"&gt;/* 2pass params (same as ffmpeg ones) */&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_qcompress&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 量化曲线(quantizer curve)压缩因子。&lt;/span&gt;
                                        &lt;span class="c1"&gt;// 0.0 =&amp;gt; 恒定比特率，1.0 =&amp;gt; 恒定量化值。&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_qblur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 时间上模糊量化，减少QP的波动(after curve compression)&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_complexity_blur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 时间上模糊复杂性，减少QP的波动(before curve compression)&lt;/span&gt;
        &lt;span class="kt"&gt;x264_zone_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;zones&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 码率控制覆盖&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;    &lt;span class="n"&gt;i_zones&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// number of zone_t&amp;#39;s&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt;  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz_zones&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 指定区的另一种方法&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 裁剪矩形窗口参数：隐式添加到分辨率非16倍数的视频中 */&lt;/span&gt;
    &lt;span class="cm"&gt;/* 在码流层指定一个切除(crop)矩形。若不想x264在编码时做crop，&lt;/span&gt;
&lt;span class="cm"&gt;       但希望解码器在回放时进行切除，可使用此项。单位为像素。 */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i_left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i_top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i_right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i_bottom&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;crop_rect&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 编码3D视频时，此参数在码流中插入一个标志，告知解码器此3D视频是如何封装&lt;/span&gt;
&lt;span class="cm"&gt;      的。3D视频帧封装格式：帧封装、场交错、线交错、左右全景、左右半景、上下半&lt;/span&gt;
&lt;span class="cm"&gt;      景、L+深度、L+深度+图形+图形深度 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_frame_packing&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* Muxing复用参数 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_aud&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                     &lt;span class="c1"&gt;// 生成访问单元分隔符&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_repeat_headers&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 是否复制sps和pps放在每个关键帧的前面&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_annexb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 值为true，则NALU之前是4字节前缀码0x00000001；&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 值为false，则NALU之前的4个字节为NALU长度&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_sps_id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// sps和pps的id号&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_vfr_input&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// VFR输入。1 ：时间基和时间戳用于码率控制  0 ：仅帧率用于码率控制&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt;  &lt;span class="n"&gt;i_fps_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 帧率的分子&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt;  &lt;span class="n"&gt;i_fps_den&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 帧率的分母&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt;  &lt;span class="n"&gt;i_timebase_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 时间基的分子&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt;  &lt;span class="n"&gt;i_timebase_den&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 时间基的分母&lt;/span&gt;

    &lt;span class="cm"&gt;/* 以某个预设模式将输入流(隔行，恒定帧率)标记为软交错(soft telecine)。默认none. 可用预设有：&lt;/span&gt;
&lt;span class="cm"&gt;      none, 22, 32, 64, double, triple, euro.  使用除none以外任一预设，都会连带开启--pic-struct */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_pulldown&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_pic_struct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 强制在Picture Timing SEI传送pic_struct. 默认是未开启&lt;/span&gt;

    &lt;span class="cm"&gt;/* 将视频流标记为交错(隔行)，哪怕并非为交错式编码。可用于编码蓝光兼容的25p和30p视频。默认是未开启 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b_fake_interlaced&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 条带参数 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_slice_max_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 每个slice的最大字节数，包括预计的NAL开销&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_slice_max_mbs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 每个slice的最大宏块数，重写i_slice_count&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_slice_count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 每帧slice的数目，每个slice必须是矩形&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="kt"&gt;x264_param_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Original post: http://nkwavelet.blog.163.com/blog/static/2277560382013102010375030/&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sun, 21 Sep 2014 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2014-09-21:libx264-x264_param_t.html</guid><category>H.264</category></item><item><title>libx264 x264_param_t (2)</title><link>http://icylord.github.io/libx264-x264_param_t-2.html</link><description>&lt;h2&gt;libx264 x264_param_t (2)&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/********************************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt; x264_image_t 结构用于存放一帧图像实际像素数据。该结构体定义在x264.h中&lt;/span&gt;
&lt;span class="cm"&gt;*********************************************************************************************/&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;     &lt;span class="n"&gt;i_csp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 设置彩色空间，通常取值 X264_CSP_I420，所有可能取值定义在x264.h中&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;     &lt;span class="n"&gt;i_plane&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;//  图像平面个数，例如彩色空间是YUV420格式的，此处取值3&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;     &lt;span class="n"&gt;i_stride&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;    &lt;span class="c1"&gt;// 每个图像平面的跨度，也就是每一行数据的字节数&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;plane&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;      &lt;span class="c1"&gt;//  每个图像平面存放数据的起始地址, plane[0]是Y平面，&lt;/span&gt;
                &lt;span class="c1"&gt;// plane[1]和plane[2]分别代表U和V平面&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  &lt;span class="kt"&gt;x264_image_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


&lt;span class="cm"&gt;/********************************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;x264_picture_t 结构体描述一视频帧的特征，该结构体定义在x264.h中。&lt;/span&gt;
&lt;span class="cm"&gt;*********************************************************************************************/&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;i_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 帧的类型，取值有X264_TYPE_KEYFRAME、X264_TYPE_P、&lt;/span&gt;
                                &lt;span class="c1"&gt;// X264_TYPE_AUTO等。初始化为auto，则在编码过程自行控制。&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;i_qpplus1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 此参数减1代表当前帧的量化参数值&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;i_pic_struct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 帧的结构类型，表示是帧还是场，是逐行还是隔行，&lt;/span&gt;
                                &lt;span class="c1"&gt;// 取值为枚举值 pic_struct_e，定义在x264.h中&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;b_keyframe&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 输出：是否是关键帧&lt;/span&gt;
    &lt;span class="kt"&gt;int64_t&lt;/span&gt;   &lt;span class="n"&gt;i_pts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 一帧的显示时间戳&lt;/span&gt;
    &lt;span class="kt"&gt;int64_t&lt;/span&gt;   &lt;span class="n"&gt;i_dts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 输出：解码时间戳。当一帧的pts非常接近0时，该dts值可能为负。&lt;/span&gt;

    &lt;span class="cm"&gt;/* 编码器参数设置，如果为NULL则表示继续使用前一帧的设置。某些参数&lt;/span&gt;
&lt;span class="cm"&gt;       (例如aspect ratio) 由于收到H264本身的限制，只能每隔一个GOP才能改变。&lt;/span&gt;
&lt;span class="cm"&gt;       这种情况下，如果想让这些改变的参数立即生效，则必须强制生成一个IDR帧。*/&lt;/span&gt; 
    &lt;span class="kt"&gt;x264_param_t&lt;/span&gt;    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;x264_image_t&lt;/span&gt;     &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 存放一帧图像的真实数据&lt;/span&gt;
    &lt;span class="kt"&gt;x264_image_properties_t&lt;/span&gt;    &lt;span class="n"&gt;prop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;x264_hrd_t&lt;/span&gt;    &lt;span class="n"&gt;hrd_timing&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 输出：HRD时间信息，仅当i_nal_hrd设置了才有效&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt;    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;opaque&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// 私有数据存放区，将输入数据拷贝到输出帧中&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="kt"&gt;x264_picture_t&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;


&lt;span class="cm"&gt;/****************************************************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;x264_nal_t中的数据在下一次调用x264_encoder_encode之后就无效了，因此必须在调用&lt;/span&gt;
&lt;span class="cm"&gt;x264_encoder_encode 或 x264_encoder_headers 之前使用或拷贝其中的数据。&lt;/span&gt;
&lt;span class="cm"&gt;*****************************************************************************************************************/&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_ref_idc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// Nal的优先级&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// Nal的类型&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_long_startcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 是否采用长前缀码0x00000001&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_first_mb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 如果Nal为一条带，则表示该条带第一个宏块的指数&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_last_mb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 如果Nal为一条带，则表示该条带最后一个宏块的指数&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_payload&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// payload 的字节大小&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p_payload&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 存放编码后的数据，已经封装成Nal单元&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="kt"&gt;x264_nal_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


&lt;span class="cm"&gt;/****************************************************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;cli_opt_t结构体主要记录一些与编码关系较小的设置信息，其变量可通过读取main()的参数获得。&lt;/span&gt;
&lt;span class="cm"&gt;*****************************************************************************************************************/&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;b_progress&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// bool类型的变量,用来控制是否显示编码进度。取值为0或1。&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;i_seek&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 整数类型 表示开始从哪一帧开始编码。&lt;/span&gt;
                            &lt;span class="c1"&gt;// 因为不一定从文件的第一帧开始编码，这是可以控制的。&lt;/span&gt;
    &lt;span class="cm"&gt;/* hnd_t(hnd=handle)是一个空指针， 定义在x264cli.h 中。void *在C语言里空指针是有几个&lt;/span&gt;
&lt;span class="cm"&gt;    特性的，它是一个一般化指针，可以指向任何一种类型，但却不能解引用，需要解引&lt;/span&gt;
&lt;span class="cm"&gt;    用的时候，需要进行强制转换。采用空指针的策略，是为了声明变量的简便和统一。 */&lt;/span&gt;
    &lt;span class="kt"&gt;hnd_t&lt;/span&gt;   &lt;span class="n"&gt;hin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 指向输入yuv文件的指针&lt;/span&gt;
    &lt;span class="kt"&gt;hnd_t&lt;/span&gt;  &lt;span class="n"&gt;hout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 指向编码过后生成的文件的指针。&lt;/span&gt;

    &lt;span class="cm"&gt;/* 一个指向文件类型的指针，它是文本文件，其每一行的格式是 ：framenum frametye  &lt;/span&gt;
&lt;span class="cm"&gt;    QP用于强制指定某些帧或者全部帧的帧类型和QP(quant param量化参数)的值. */&lt;/span&gt;
    &lt;span class="kt"&gt;FILE&lt;/span&gt;   &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;qpfile&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="kt"&gt;cli_opt_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Original post: http://nkwavelet.blog.163.com/blog/static/2277560382013102923912753/&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sun, 21 Sep 2014 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2014-09-21:libx264-x264_param_t-2.html</guid><category>H.264</category></item><item><title>x264_encoder_encode analysis</title><link>http://icylord.github.io/x264_encoder_encode-analysis.html</link><description>&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*****************************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt; *  x264_encoder_encode:    该函数定义在encoder/encoder.c文件中&lt;/span&gt;
&lt;span class="cm"&gt; *  XXX : i_poc   :  is the poc of the current given picture&lt;/span&gt;
&lt;span class="cm"&gt; *         i_frame  :  is the number of the frame being coded&lt;/span&gt;
&lt;span class="cm"&gt; *  ex:  type  frame    poc&lt;/span&gt;
&lt;span class="cm"&gt; *         I       0       2*0&lt;/span&gt;
&lt;span class="cm"&gt; *         P       1       2*3&lt;/span&gt;
&lt;span class="cm"&gt; *         B       2       2*1&lt;/span&gt;
&lt;span class="cm"&gt; *         B       3       2*2&lt;/span&gt;
&lt;span class="cm"&gt; *         P       4       2*6&lt;/span&gt;
&lt;span class="cm"&gt; *         B       5       2*4&lt;/span&gt;
&lt;span class="cm"&gt; *         B       6       2*5&lt;/span&gt;
&lt;span class="cm"&gt; 要搞清poc和frame的区别。假设一个视频播放序列如下 :   I   B   B   P   B   B   P&lt;/span&gt;
&lt;span class="cm"&gt; 我们编码是按I   P   B   B   P   B   B的顺序, 这就是frame的编号，也就是编码序号。&lt;/span&gt;
&lt;span class="cm"&gt; 而我们视频序列的播放序号是POC的序号,这里是乘以了2.，也就是播放序号。&lt;/span&gt;
&lt;span class="cm"&gt; 注意：考虑到场编码，POC每帧增长为2，如果是场编码POC增长为1.&lt;/span&gt;
&lt;span class="cm"&gt; 注意：本人debug详细跟踪了20多帧，观察该函数的编码流程及变量的变化，详细的&lt;/span&gt;
&lt;span class="cm"&gt; 过程举例可见 x264_encoder_encode编码过程详细举例  &lt;/span&gt;
&lt;span class="cm"&gt; ************************************************************************************************/&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="nf"&gt;x264_encoder_encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;x264_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="kt"&gt;x264_nal_t&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;pp_nal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi_nal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="kt"&gt;x264_picture_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pic_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="kt"&gt;x264_picture_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pic_out&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* no data out */&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi_nal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp_nal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


    &lt;span class="cm"&gt;/* ------------------- Setup new frame from picture -------------------- */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;pic_in&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;          &lt;span class="cm"&gt;/* 1: Copy the picture to a frame and move it to a buffer */&lt;/span&gt;

        &lt;span class="c1"&gt;// 从unused队列里取出一帧给fenc，该函数定义在common/frame.c中&lt;/span&gt;
        &lt;span class="c1"&gt;// 该函数的详细分析见：x264_frame_pop_unused函数代码分析&lt;/span&gt;
        &lt;span class="kt"&gt;x264_frame_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x264_frame_pop_unused&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// 然后将输入的YUV数据复制到fenc的缓冲区里，该函数定义在common/frame.c中&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;x264_frame_copy_picture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pic_in&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// 图像宽度和高度不为16的倍数时进行扩边，该函数定义在文件 common/frame.c 中&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_width&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_mb_width&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_height&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_mb_height&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;x264_frame_expand_border_mod16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// h-&amp;gt;frames.i_input记录图像的输入顺序。将fenc指针放到next队列里&lt;/span&gt;
        &lt;span class="c1"&gt;// 全局控制输入帧数的h-&amp;gt;frames.i_input自增，同时给当前帧数的 &lt;/span&gt;
        &lt;span class="c1"&gt;// fenc-&amp;gt;i_frame赋值，此处的fenc-&amp;gt;i_frame其实就是poc &lt;/span&gt;
        &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_input&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// dts 解码时间戳，pts显示时间戳分别是解码器进行解码和显示时间&lt;/span&gt;
        &lt;span class="c1"&gt;// 如果是第一帧的话 全局控制帧的时间戳等于最开始图像所赋值的那个时间戳&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_first_pts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// h-&amp;gt;frames.i_bframe_delay 是最开始通过参数(应该是i_bframe)设置的，&lt;/span&gt;
        &lt;span class="c1"&gt;// h-&amp;gt;frames.i_bframe_delay 的获取详见：x264_encoder_open 函数代码分析&lt;/span&gt;
        &lt;span class="c1"&gt;// 如果是B帧进行预测话，要缓存起来。当全局控制帧数目等于B帧延缓的&lt;/span&gt;
        &lt;span class="c1"&gt;// 数目时，就设置B帧延迟时间为当前时间戳与第一帧时间戳之差&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bframe_delay&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bframe_delay&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bframe_delay_time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pts&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_first_pts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* 时间基和时间戳用于码率控制，当前编码的时间戳比已知的最大时间戳还小，则报Warning信息  */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_vfr_input&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pts&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_largest_pts&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;x264_log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;X264_LOG_WARNING&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;non-strictly-monotonic PTS&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// 这两个应该是循环进行的,设置当前的最大和次大时间戳&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_second_largest_pts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_largest_pts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_largest_pts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// 根据条件编译判断是否存在场，和根据设置来看编码帧到底是帧场的类型&lt;/span&gt;
        &lt;span class="c1"&gt;// 图片结构类型：顶场、底场、逐行、double、triple、auto等，定义在x264.h中。通常图片结构类型为0，即auto&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pic_struct&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;PIC_STRUCT_AUTO&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pic_struct&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;PIC_STRUCT_TRIPLE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pic_struct&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PIC_STRUCT_AUTO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pic_struct&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;PIC_STRUCT_AUTO&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c1"&gt;// 目前不考虑隔行，因此结构为逐行&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b_interlaced&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;
                &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pic_struct&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PIC_STRUCT_PROGRESSIVE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;// 2 pass mode&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_mb_tree&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_stat_read&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// 量化是可以配置的，通过配置可以自适应量化，也可以从外部读取固定的量化矩阵&lt;/span&gt;
            &lt;span class="c1"&gt;// 读取固定的量化矩阵，从stat中读取类型和qp_offset，利用这些预测信息进行编码&lt;/span&gt;
            &lt;span class="n"&gt;x264_macroblock_tree_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pic_in&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prop&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quant_offsets&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// x264的堆栈对齐，无非就是平台优化方面考虑的对齐操作&lt;/span&gt;
            &lt;span class="n"&gt;x264_stack_align&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x264_adaptive_quant_frame&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pic_in&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prop&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quant_offsets&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;// 忽略，该参数解释见x264.h中x264_image_properties_t结构体&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;pic_in&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prop&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quant_offsets_free&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;pic_in&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prop&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quant_offsets_free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;pic_in&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prop&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quant_offsets&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// 对进入待编码队列的帧进行下采样, 由参数h-&amp;gt;frames.b_have_lowres控制；&lt;/span&gt;
        &lt;span class="c1"&gt;// 亮度1/2像素值初始化，函数x264_frame_init_lowres定义在common/mc.c中&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_have_lowres&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;x264_frame_init_lowres&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/* 2: Place the frame into the queue for its slice type decision */&lt;/span&gt;
        &lt;span class="c1"&gt;// 将编码帧fenc保存在链表h-&amp;gt;lookahead-&amp;gt;next中，该函数定义在encoder/lookahead.c中&lt;/span&gt;
        &lt;span class="c1"&gt;// 该函数调用x264_sync_frame_list_push来实现将fenc添加到链表h-&amp;gt;lookahead-&amp;gt;next-&amp;gt;list中&lt;/span&gt;
        &lt;span class="c1"&gt;// 函数x264_sync_frame_list_push定义在common/frame.c中，该函数非常简短&lt;/span&gt;
        &lt;span class="c1"&gt;// 该函数代码详细分析见：x264_lookahead_put_frame函数代码分析&lt;/span&gt;
        &lt;span class="n"&gt;x264_lookahead_put_frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fenc&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// 编码的延迟帧数为h-&amp;gt;frames.i_delay + 1 - h-&amp;gt;i_thread_frames。&lt;/span&gt;
        &lt;span class="c1"&gt;// 单线程时延迟帧数为h-&amp;gt;frames.i_delay。当h-&amp;gt;frames.i_input &amp;gt; h-&amp;gt;frames.i_delay&lt;/span&gt;
        &lt;span class="c1"&gt;// 进行编码，否则返回。也就是说当编码第一帧时，next队列里缓存了&lt;/span&gt;
        &lt;span class="c1"&gt;// （h-&amp;gt;frames.i_delay + 1 - h-&amp;gt;i_thread_frames）帧数据。&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_input&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_thread_frames&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* Nothing yet to encode, waiting for filling of buffers */&lt;/span&gt;
            &lt;span class="n"&gt;pic_out&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;X264_TYPE_AUTO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// 多线程有关，暂时忽略&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;lookahead&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_exit_thread&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;x264_pthread_cond_broadcast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;lookahead&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ifbuf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cv_fill&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 编码帧数加1&lt;/span&gt;

    &lt;span class="cm"&gt;/* 3: The picture is analyzed in the lookahead */&lt;/span&gt;

    &lt;span class="c1"&gt;// 当h-&amp;gt;frames.current[0]为空时，需要对next队列里的帧进行重排序，将排序后的当前编码帧指针放到current队列里。&lt;/span&gt;
    &lt;span class="c1"&gt;// 重排序的方法是调用x264_slicetype_decide()产生next队列里各帧的帧类型，&lt;/span&gt;
    &lt;span class="c1"&gt;// 然后将next队列里的非B帧先压到current队列里，再将next队列里的B帧压到current队列里。 &lt;/span&gt;
    &lt;span class="c1"&gt;// 注意：当h-&amp;gt;frames.current[0]不为空时，表明h-&amp;gt;frames.current[0]里的帧的顺序已经重排序了，不需要再更改。&lt;/span&gt;
    &lt;span class="c1"&gt;// x264_lookahead_get_frames定义在encoder/lookahead.c中，详细分析见：x264_lookahead_get_frames函数代码分析&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;x264_lookahead_get_frames&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;x264_lookahead_is_empty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x264_encoder_frame_end&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thread_oldest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;thread_current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pp_nal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pi_nal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pic_out&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* ------------------- Get frame to be encoded ------------------------- */&lt;/span&gt;

    &lt;span class="cm"&gt;/* 4: get picture to encode */&lt;/span&gt;
    &lt;span class="c1"&gt;// 将current[0]指针pop到fenc里，开始编码；函数x264_frame_shift定义在common/frame.c中，很简短&lt;/span&gt;
    &lt;span class="c1"&gt;// 就是将h-&amp;gt;frames.current[0]指针pop给h-&amp;gt;fenc，然后后面的指针依次往前移动一个位置&lt;/span&gt;
    &lt;span class="c1"&gt;// 该函数代码分析详见：x264_frame_xxxx 系列函数代码分析&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x264_frame_shift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;//从当前编码帧中取出第一帧，作为当前编码帧&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_thread_frames&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_reordered_pts_delay&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_reordered_pts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// 运行过程中动态调整编码参数 &lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;x264_encoder_reconfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param_free&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param_free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;


    &lt;span class="c1"&gt;// 判断上一帧重构fdec是否做参考帧，如果是参考帧，放到reference队列里，&lt;/span&gt;
    &lt;span class="c1"&gt;// 然后从unused队列里取出一帧作为当前的参考工作帧（即解码操作的目的帧），即h-&amp;gt;fdec。&lt;/span&gt;
    &lt;span class="c1"&gt;// 如果上一重构帧不是参考帧（比如B帧），直接返回。&lt;/span&gt;
    &lt;span class="c1"&gt;// 函数x264_reference_updata定义在encoder/encoder.c中，代码分析见：x264_reference_xxxx代码分析&lt;/span&gt;
    &lt;span class="c1"&gt;// ok to call this before encoding any frames, since the initial values of fdec have b_kept_as_ref=0&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;x264_reference_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_lines_completed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 以像素为单位&lt;/span&gt;


    &lt;span class="c1"&gt;// 如果当前编码帧不是I帧（包括普通I帧和IDR帧）&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;IS_X264_TYPE_I&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// 检查有效参考帧的数目&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;valid_refs_left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reference&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reference&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_corrupt&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;valid_refs_left&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* No valid reference frames left : force an IDR. */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;valid_refs_left&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;    
            &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_keyframe&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 设置为关键帧&lt;/span&gt;
            &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;X264_TYPE_IDR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// IDR帧&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;    
    &lt;span class="p"&gt;}&lt;/span&gt;  

    &lt;span class="c1"&gt;// 如果当前帧是关键帧&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_keyframe&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// 设置关键帧的poc（播放）序号&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_last_keyframe&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// 如果是IDR帧，则设置IDR帧的poc序号&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;X264_TYPE_IDR&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame_num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
            &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_last_idr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;    
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_mmco_command_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_mmco_remove_from_end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_ref_reorder&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_ref_reorder&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_poc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;            &lt;span class="c1"&gt;// 考虑到场编码，POC每帧增长为2，如果是场编码POC增长为1&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_poc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;X264_MAX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_last_idr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* ------------------- Setup frame context ----------------------------- */&lt;/span&gt;

    &lt;span class="c1"&gt;// 根据帧的类型初始化数据。五种片的类型：IDR，I，P，BREF，B 。帧类型定义在x264.h中.&lt;/span&gt;
    &lt;span class="c1"&gt;// 如果是解码即时刷新片（IDR），则要对参考帧重新设置&lt;/span&gt;
    &lt;span class="c1"&gt;// 下面的 x264_reference_xxxx等函数代码分析见：x264_reference_xxxx 系列函数代码分析&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;X264_TYPE_IDR&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;// 值1&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* reset ref pictures */&lt;/span&gt;
        &lt;span class="n"&gt;i_nal_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NAL_SLICE_IDR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 值5，定义在x264.h中&lt;/span&gt;
        &lt;span class="n"&gt;i_nal_ref_idc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NAL_PRIORITY_HIGHEST&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 值3，定义在x264.h中&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SLICE_TYPE_I&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 值2，定义在common/common.h中&lt;/span&gt;
        &lt;span class="n"&gt;x264_reference_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// 该函数定义在encoder/encoder.c中&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_poc_last_open_gop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;X264_TYPE_I&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 值2&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;i_nal_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NAL_SLICE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 值1，定义在x264.h中&lt;/span&gt;
        &lt;span class="n"&gt;i_nal_ref_idc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NAL_PRIORITY_HIGH&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 值2，定义在x264.h中&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SLICE_TYPE_I&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 值2，定义在common/common.h中&lt;/span&gt;
        &lt;span class="n"&gt;x264_reference_hierarchy_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 该函数定义在encoder/encoder.c中&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_open_gop&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_poc_last_open_gop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_keyframe&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_poc&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;X264_TYPE_P&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 值3&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;i_nal_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NAL_SLICE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 值1，定义在x264.h中&lt;/span&gt;
        &lt;span class="n"&gt;i_nal_ref_idc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NAL_PRIORITY_HIGH&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 值2，定义在x264.h中&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SLICE_TYPE_P&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 值0，定义在common/common.h中&lt;/span&gt;
        &lt;span class="n"&gt;x264_reference_hierarchy_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 该函数定义在encoder/encoder.c中&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_poc_last_open_gop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;X264_TYPE_BREF&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;// 值4&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;i_nal_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NAL_SLICE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 值1，定义在x264.h中&lt;/span&gt;
        &lt;span class="n"&gt;i_nal_ref_idc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bframe_pyramid&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;X264_B_PYRAMID_STRICT&lt;/span&gt; 
            &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;NAL_PRIORITY_LOW&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;NAL_PRIORITY_HIGH&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SLICE_TYPE_B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 值1，定义在common/common.h中&lt;/span&gt;
        &lt;span class="n"&gt;x264_reference_hierarchy_reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 该函数定义在encoder/encoder.c中&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;        &lt;span class="cm"&gt;/* B frame */&lt;/span&gt;                   &lt;span class="c1"&gt;// 帧类型： X264_TYPE_B = 5&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;i_nal_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NAL_SLICE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 值1，定义在x264.h中&lt;/span&gt;
        &lt;span class="n"&gt;i_nal_ref_idc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NAL_PRIORITY_DISPOSABLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 值0，定义在x264.h中&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SLICE_TYPE_B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 值1，定义在common/common.h中&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_kept_as_ref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;                    &lt;span class="c1"&gt;// 只要帧的类型不是X264_TYPE_B，就可以作为参考帧&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_kept_as_ref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i_nal_ref_idc&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;NAL_PRIORITY_DISPOSABLE&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_keyint_max&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 

    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mb_info&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mb_info&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mb_info_free&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mb_info_free&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mb_info&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mb_info_free&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// B帧延迟的帧数，该值在函数 x264_encoder_open 中设置，可见：x264_encoder_open 函数代码分析&lt;/span&gt;
    &lt;span class="c1"&gt;// 如果命令行参数--bframes 没有设置，在此处frames.i_bframe_delay的值就是0&lt;/span&gt;
    &lt;span class="c1"&gt;// 如果--bframes设置了，在i_bframe_delay取值1或者2，由命令行参数--b-pyramid决定&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bframe_delay&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int64_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;prev_reordered_pts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;thread_current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_prev_reordered_pts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_dts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bframe_delay&lt;/span&gt;
            &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;prev_reordered_pts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bframe_delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bframe_delay&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_reordered_pts&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bframe_delay_time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;prev_reordered_pts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bframe_delay&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_reordered_pts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; 
    &lt;span class="k"&gt;else&lt;/span&gt; 
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_dts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_reordered_pts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;X264_TYPE_IDR&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_last_idr_pts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_pts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* -------------------  Init  ----------------------------- */&lt;/span&gt;

    &lt;span class="cm"&gt;/* 创建list0和list1（ref0和ref1），ref0从大到小，ref1从小到大 */&lt;/span&gt;
    &lt;span class="cm"&gt;/* 在这个函数中，我们将遇到参考帧列表h-&amp;gt;frames.reference和H.264很有特色的双列表（h-&amp;gt;fref0、h-&amp;gt;fref1）。&lt;/span&gt;
&lt;span class="cm"&gt;       前者中放置了所有可用于参考的参考帧。 首先将所有reference列表中的帧按照POC和h-&amp;gt;fenc的POC的大小&lt;/span&gt;
&lt;span class="cm"&gt;       关系不同复制到双列表中，其中h-&amp;gt;fref0放置POC较小的那些。然后对双列表进行排序，使得h-&amp;gt;fref0中的帧&lt;/span&gt;
&lt;span class="cm"&gt;       POC按从大到小排列，h-&amp;gt;fref1按从小到大排列，于是这两个列表中靠前的帧的POC比较接近当前帧h-&amp;gt;fenc。&lt;/span&gt;
&lt;span class="cm"&gt;       在这里，一个特殊的情况是，对于P帧（只需要用到列表h-&amp;gt;fref0做参考），其排序依据是i_frame_num而不是&lt;/span&gt;
&lt;span class="cm"&gt;       POC，因此需要对这种情况的列表h-&amp;gt;fref0置位需重排序标记。最后对双列表的长度做限制。*/&lt;/span&gt;
    &lt;span class="c1"&gt;// 该函数的详细代码分析见：x264_reference_xxxx代码分析&lt;/span&gt;
    &lt;span class="n"&gt;x264_reference_build_list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_poc&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;



    &lt;span class="cm"&gt;/* ---------------------- Write the bitstream -------------------------- */&lt;/span&gt;
    &lt;span class="cm"&gt;/* Init bitstream context */&lt;/span&gt;
    &lt;span class="c1"&gt;// 是否使用基于slice的线程，如果为false，则一个slice编码成一个NALU&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_sliced_threads&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_threads&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;bs_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;p_bitstream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bitstream&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_nal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;bs_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;p_bitstream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_bitstream&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_nal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// 是否生成访问单元分隔符，默认值为0，通常不作修改。可以使用命令行参数 -aud 改变默认值。&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_aud&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...}&lt;/span&gt;      &lt;span class="c1"&gt;// 忽略&lt;/span&gt;

    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_nal_type&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i_nal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_nal_ref_idc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i_nal_ref_idc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// 是否用周期帧内刷新替代IDR，默认值为0&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_intra_refresh&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// 待编码的是否是关键帧&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_keyframe&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Write SPS and PPS */&lt;/span&gt;
        &lt;span class="c1"&gt;// 是否需要复制SPS和PPS放置在每个IDR帧（关键帧）的前面&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_repeat_headers&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="cm"&gt;/* when frame threading is used, buffering period sei is written in x264_encoder_frame_end,  忽略 */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_thread_frames&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sps&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;vui&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_nal_hrd_parameters_present&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* write extra sei, 忽略 */&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;extra_sei&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;num_payloads&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;extra_sei&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sei_free&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_keyframe&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Avid&amp;#39;s decoder strictly wants two SEIs for AVC-Intra so we can&amp;#39;t insert the x264 SEI,忽略 */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_repeat_headers&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;X264_TYPE_IDR&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 非 IDR 帧的 I 帧&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_frame_packing&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c1"&gt;// 用于3D视频编码，通常该变量取值-1，忽略&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* generate sei pic timing，忽略 */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sps&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;vui&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_pic_struct_present&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sps&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;vui&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_nal_hrd_parameters_present&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* As required by Blu-ray.  忽略 */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;IS_X264_TYPE_B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_sh_backup&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b_keyframe&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_intra_refresh&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_cpb_delay_pir_offset_next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_cpb_delay&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


    &lt;span class="cm"&gt;/* Filler space: 10 or 18 SEIs&amp;#39; worth of space, depending on resolution */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_avcintra_class&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* Init the rate control */&lt;/span&gt;
    &lt;span class="c1"&gt;// 初始化码率控制，初始化之后，从码率控制体中获取全局的QP值&lt;/span&gt;
    &lt;span class="c1"&gt;// 函数x264_ratecontrol_start定义在encoder/ratecontrol.c中，&lt;/span&gt;
    &lt;span class="c1"&gt;// 该函数代码详细分析可参考：x264_ratecontrol_start 函数代码分析&lt;/span&gt;
    &lt;span class="n"&gt;x264_ratecontrol_start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fenc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_qpplus1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;overhead&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;i_global_qp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x264_ratecontrol_qp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 很简短，定义在encoder/ratecontrol.c中，将h-&amp;gt;rc-&amp;gt;qpm四舍五入，然后取整&lt;/span&gt;

    &lt;span class="n"&gt;pic_out&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_qpplus1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_qpplus1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i_global_qp&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b_stat_read&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;SLICE_TYPE_I&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_ref&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fdec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_poc_l0ref0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fref&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_poc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* ------------------------ Create slice header  ----------------------- */&lt;/span&gt;

    &lt;span class="c1"&gt;// 该函数定义在encoder/encoder.c中，详细分析见：x264_slice_init 函数代码分析&lt;/span&gt;
    &lt;span class="n"&gt;x264_slice_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i_nal_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i_global_qp&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;


    &lt;span class="cm"&gt;/*------------------------- Weights -------------------------------------*/&lt;/span&gt;
    &lt;span class="c1"&gt;// 如果当前是B条带（帧），则调用x264_macroblock_bipred_init，该函数设置一些参考帧关系矩阵，&lt;/span&gt;
    &lt;span class="c1"&gt;// 关系矩阵以fref0的索引为行坐标，以fref1的索引为列坐标。主要包括：dist_scale_factor，bipred_weight，&lt;/span&gt;
    &lt;span class="c1"&gt;// 矩阵值主要由相应帧的POC决定。后续讨论。&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;SLICE_TYPE_B&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;x264_macroblock_bipred_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 权值预测 但是不清楚是哪一部分的权值，该函数定义在encoder/encoder.c中&lt;/span&gt;
    &lt;span class="n"&gt;x264_weighted_pred_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;i_nal_ref_idc&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;NAL_PRIORITY_DISPOSABLE&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_frame_num&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* Write frame , 最重要的函数，对一帧编码 */&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_threadslice_start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_threadslice_end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i_mb_height&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// 对一个slice进行编码，详细分析见：x264_slice_write 函数代码分析&lt;/span&gt;
    &lt;span class="n"&gt;x264_slices_write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 编码结束, 统计编码时间、psnr、mb类型比例、释放编码分配的空间，该函数定义在encoder/encoder.c中&lt;/span&gt;
    &lt;span class="n"&gt;x264_encoder_frame_end&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;thread_oldest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;thread_current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pp_nal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pi_nal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pic_out&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;x264_reference_update&lt;/span&gt;           &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_frame_pop_unused&lt;/span&gt;           &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;common&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_frame_copy_picture&lt;/span&gt;         &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;common&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_frame_init_lowres&lt;/span&gt;          &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;common&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_lookahead_put_frame&lt;/span&gt;        &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lookahead&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_lookahead_get_frames&lt;/span&gt;       &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lookahead&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_frame_shift&lt;/span&gt;                &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;common&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_encoder_reconfig&lt;/span&gt;           &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_reference_build_list&lt;/span&gt;       &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_ratecontrol_start&lt;/span&gt;          &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ratecontrol&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_ratecontrol_qp&lt;/span&gt;             &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ratecontrol&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_slice_init&lt;/span&gt;                 &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_slices_write&lt;/span&gt;               &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_weighted_pred_init&lt;/span&gt;         &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_threaded_slices_write&lt;/span&gt;      &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;span class="n"&gt;x264_encoder_frame_end&lt;/span&gt;          &lt;span class="err"&gt;定义在文件&lt;/span&gt;    &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Original post: http://nkwavelet.blog.163.com/blog/static/22775603820131115931476/&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sun, 21 Sep 2014 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2014-09-21:x264_encoder_encode-analysis.html</guid><category>H.264</category></item><item><title>Implement virtual camera on Windows 7 using DirectShow</title><link>http://icylord.github.io/implement-virtual-camera-on-windows-7-using-directshow.html</link><description>&lt;h2&gt;Windows7下使用Directshow实现虚拟摄像头&lt;/h2&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;近期碰到了个项目，破解了某个摄像头设备的视频数据流到PC的方法(Linux+RTSP Streaming -&amp;gt; PC -&amp;gt; Virtual Camera -&amp;gt; Skype/Link/QQ)，打算扔掉这个设备自带的驱动，自己写一个，需要在Windows平台下实现一个虚拟摄像头，使得Skype、QQ等聊天软件能够使用远端的Web Camera设备的视频数据作为输入端进行视频聊天，在网上搜刮了一番资料后，花了点时间将其实现了。近期有时间，就把整个实现方法和过程写下来方便以后回顾&lt;/p&gt;
&lt;p&gt;在进行之前首先需要知道什么是&lt;strong&gt;DirectShow&lt;/strong&gt;和&lt;strong&gt;DirectShow filter。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DirectShow&lt;/strong&gt;（摘自wikipedia）：DirectShow (sometimes abbreviated as DS or DShow), codename Quartz, is a multimedia framework and API produced by Microsoft for software developers to perform various operations with media files or streams. It is the replacement for Microsoft's earlier Video for Windows technology. &lt;strong&gt;Based on the Microsoft Windows Component Object Model (COM) framework, DirectShow provides a common interface for media across various programming languages, and is an extensible, filter-based framework that can render or record media files on demand at the request of the user or developer&lt;/strong&gt;. 也就是说，DirectShow为多媒体流的捕捉和回放提供了强而有力的支持。 通过DirectShow，我们可以很方便地从支持WDM驱动模型的采集卡上采集数据，并进行相应的后期处理乃至存储到文件当中。DirectShow是一种开放式的开发环境，我们可以根据自己的需求定制自己的组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DirectShow Filter&lt;/strong&gt;（摘自MSDN）：DirectShow provides a set of default filters in Windows. &lt;strong&gt;These filters support many data formats while providing a high degree of hardware independence&lt;/strong&gt;. An application can also register and install custom filters on the target system. DirectShow是基于模块化的，每个功能模块采取COM组件的方式，成为Filter。Filter是DirectShow的最基本的概念。DirectShow使用Filter Graph来管理Filter。Filter Graph是Filter的“容器”，而Filter是Filter Graph的最小功能模块。粗略地说，可以认为Filter是一个插件。 我们可以自定义实现Filter提供给Filter Graph来使用达到我们特殊的应用目的。&lt;/p&gt;
&lt;p&gt;DirectShow Filter包括&lt;strong&gt;Source Filter&lt;/strong&gt;、&lt;strong&gt;Transform Filter&lt;/strong&gt;和&lt;strong&gt;Render Filter&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Windows平台下，常见的聊天软件都是使用DirectShow获取摄像头并得到图像数据的，因此若要实现一个虚拟摄像头的功能，DirectShow是必不可少的。 至于DirectShow Filter，因为在需要实现的虚拟摄像头的功能中，图像的输入数据并不是直接由摄像头的提供方提供的驱动得到硬件设备数据，而是我们自己提供的数据，比如可以使本地的视频文件，或者是远端的图像数据。 微软提供了DirectShow Filter这种框架可以方便开发者进行自定义的数据输入的功能，当然，这只是DirectShow Filter能够做到的众多功能其中之一。 本文使用的是DirectShow Filter中的其中的Source Filter。&lt;/p&gt;
&lt;p&gt;下面给出一张实现了需要摄像头后，QQ选取摄像头设备的效果图，其中Virtual Camera为虚拟的设备：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/static/img/virtualcameraselection.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;实现虚拟摄像头需要进行如下步骤：&lt;/p&gt;
&lt;p&gt;（1）实现DLL注册函数，使得虚拟的设备能够在聊天软件或者VLC等软件在DShow列表中选取；&lt;/p&gt;
&lt;p&gt;（2）实现DirectShow Source Filter，包括得到图像输入数据，转换成标准的输出格式，提供给调用此Source filter的调用对象；&lt;/p&gt;
&lt;p&gt;（3）将生成的Dll文件注册到系统注册表中。&lt;/p&gt;
&lt;h3&gt;下面按照步骤逐一介绍实现方法&lt;/h3&gt;
&lt;h3&gt;第一部分&lt;/h3&gt;
&lt;p&gt;Filter是一个基于Dll的COM组件，一般Filter需要实现下面几个入口函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DllMain&lt;/li&gt;
&lt;li&gt;DllRegisterServer&lt;/li&gt;
&lt;li&gt;DllUnregisterServer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体可以参考DirectShow自带的Ball例子。需要注意的是，要使得设备能够被DirectShow选取到，则需要额外实现将Dll注册为CLSID_VideoInputDeviceCategory的函数。见下面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;STDAPI&lt;/span&gt; &lt;span class="nf"&gt;DllRegisterServer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;RegisterFilters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;STDAPI&lt;/span&gt; &lt;span class="nf"&gt;DllUnregisterServer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;RegisterFilters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;WINAPI&lt;/span&gt; &lt;span class="n"&gt;DllEntryPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HINSTANCE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ULONG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LPVOID&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;APIENTRY&lt;/span&gt; &lt;span class="nf"&gt;DllMain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HANDLE&lt;/span&gt; &lt;span class="n"&gt;hModule&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                      &lt;span class="n"&gt;DWORD&lt;/span&gt;  &lt;span class="n"&gt;dwReason&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                      &lt;span class="n"&gt;LPVOID&lt;/span&gt; &lt;span class="n"&gt;lpReserved&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;DllEntryPoint&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;HINSTANCE&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;hModule&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;dwReason&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lpReserved&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;STDAPI&lt;/span&gt; &lt;span class="nf"&gt;RegisterFilters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;bRegister&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NOERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;WCHAR&lt;/span&gt; &lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_PATH&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_PATH&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;ASSERT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g_hInst&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;GetModuleFileNameA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g_hInst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; 
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;AmHresultFromWin32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GetLastError&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;MultiByteToWideChar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CP_ACP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lstrlenA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
        &lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NUMELMS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CoInitialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bRegister&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// The AMovieDllRegisterServer2 function creates registry entries for every component in the g_Templates&lt;/span&gt;
        &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AMovieSetupRegisterServer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;g_wszName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;L&amp;quot;Both&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;L&amp;quot;InprocServer32&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUCCEEDED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;IFilterMapper2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pFM2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CoCreateInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_FilterMapper2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CLSCTX_INPROC_SERVER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;IID_IFilterMapper2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUCCEEDED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bRegister&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;IMoniker&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pMoniker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;RegisterFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;g_wszName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pMoniker&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;CLSID_VideoInputDeviceCategory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rf2FilterReg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;UnregisterFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;CLSID_VideoInputDeviceCategory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;// release interface&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Release&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUCCEEDED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;bRegister&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AMovieSetupUnregisterServer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;CoFreeUnusedLibraries&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;CoUninitialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中CLSID_VirtualCamera为我们自己生成的GUID，每个COM组件使用一个唯一的GUID来标识，当创建一个COM组件的时候，都是首先通过该ID调用CoCreateInstance函数来创建对应的组件类工厂。我们可以使用自带软件GUID Generator生成，见图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/static/img/guid.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;生成后，将Result部分贴到源代码当中，并将name修改成我们自定义的名称，比如CLSID_VirtualCamera&lt;/p&gt;
&lt;p&gt;按照上述，将编译好的Dll进行注册，那么应该可以在聊天软件中的下拉列表看到我们虚拟出来的设备名称了。前提是已经实现了Source Filter，否则会编译不过的，呵呵。因为关键的Filter类还没有实现！&lt;/p&gt;
&lt;h3&gt;第二部分&lt;/h3&gt;
&lt;p&gt;Source Filter的实现
关键是需要实现继承CSource和CSourceStream这两个类，并实现相关的接口，列举如下：&lt;/p&gt;
&lt;p&gt;其中CSourceStream的子类必须继承IAMStreamConfig, IKsPropertySet这两个接口&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;VirtualCamera&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;CSource&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;

    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;CUnknown&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;WINAPI&lt;/span&gt; &lt;span class="n"&gt;CreateInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LPUNKNOWN&lt;/span&gt; &lt;span class="n"&gt;lpunk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;QueryInterface&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFIID&lt;/span&gt; &lt;span class="n"&gt;riid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;ppv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;IFilterGraph&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;GetGraph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;m_pGraph&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;

    &lt;span class="c1"&gt;// It is only allowed to to create these objects with CreateInstance&lt;/span&gt;
    &lt;span class="n"&gt;VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LPUNKNOWN&lt;/span&gt; &lt;span class="n"&gt;lpunk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;Stop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;VirtualCameraStream&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;CSourceStream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IAMStreamConfig&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IKsPropertySet&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="nl"&gt;public:&lt;/span&gt;

    &lt;span class="n"&gt;VirtualCameraStream&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;VirtualCamera&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pParent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LPCWSTR&lt;/span&gt; &lt;span class="n"&gt;pPinName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;VirtualCameraStream&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// plots a ball into the supplied video frame&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;FillBuffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IMediaSample&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pms&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Ask for buffers of the size appropriate to the agreed media type&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;DecideBufferSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IMemAllocator&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pIMemAlloc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                             &lt;span class="n"&gt;ALLOCATOR_PROPERTIES&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pProperties&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Set the agreed media type, and set up the necessary ball parameters&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;SetMediaType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CMediaType&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pMediaType&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Because we calculate the ball there is no reason why we&lt;/span&gt;
    &lt;span class="c1"&gt;// can&amp;#39;t calculate it in any one of a set of formats...&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;CheckMediaType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CMediaType&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pMediaType&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;GetMediaType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;iPosition&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CMediaType&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pmt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Resets the stream time to zero&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;OnThreadCreate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Quality control notifications sent to us&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;Notify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IBaseFilter&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pSender&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Quality&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//  IUnknown&lt;/span&gt;
    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;QueryInterface&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFIID&lt;/span&gt; &lt;span class="n"&gt;riid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;ppv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ULONG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;AddRef&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GetOwner&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;AddRef&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ULONG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;Release&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GetOwner&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Release&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//  IAMStreamConfig&lt;/span&gt;
    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="n"&gt;SetFormat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AM_MEDIA_TYPE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pmt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;GetFormat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AM_MEDIA_TYPE&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;ppmt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;GetNumberOfCapabilities&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;piCount&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;piSize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;GetStreamCaps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;iIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AM_MEDIA_TYPE&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;pmt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BYTE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pSCC&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//  IKsPropertySet&lt;/span&gt;
    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFGUID&lt;/span&gt; &lt;span class="n"&gt;guidPropSet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;dwID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pPropData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbPropData&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;Get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFGUID&lt;/span&gt; &lt;span class="n"&gt;guidPropSet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;dwPropID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pPropData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbPropData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pcbReturned&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;QuerySupported&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFGUID&lt;/span&gt; &lt;span class="n"&gt;guidPropSet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;dwPropID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pTypeSupport&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nl"&gt;private:&lt;/span&gt;
    &lt;span class="n"&gt;CCritSec&lt;/span&gt; &lt;span class="n"&gt;shared_state_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// Lock on shared_state_&lt;/span&gt;
    &lt;span class="n"&gt;CRefTime&lt;/span&gt; &lt;span class="n"&gt;sample_time_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// The time stamp for each sample&lt;/span&gt;
    &lt;span class="n"&gt;VirtualCamera&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;此部分持续更新&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;第三部分&lt;/h3&gt;
&lt;p&gt;实现完毕并且编译得到的Filter Dll需要注册到注册表中，才得到我们能够选取到的虚拟摄像头。 Filter本身是种COM组件，一般使用regsvr32.exe将其注册到注册表中。具体用法为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册：regsvr32.exe XXX.dll&lt;/li&gt;
&lt;li&gt;反注册： regsvr32.exe -u XXX.dll&lt;/li&gt;
&lt;li&gt;如果想取消注册完成的弹出提示窗口，可以再regsvr32.exe之后加上-s参数&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Tue, 01 Jul 2014 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2014-07-01:implement-virtual-camera-on-windows-7-using-directshow.html</guid><category>Directshow</category></item><item><title>Compile MYSQL++ in VS2010</title><link>http://icylord.github.io/compile-mysql-in-vs2010.html</link><description>&lt;p&gt;1、到http://tangentsoft.net/mysql++/下载mysql++-3.2.1 &lt;/p&gt;
&lt;p&gt;链接:&lt;a href="http://tangentsoft.net/mysql++/releases/mysql++-3.2.1.tar.gz"&gt;MYSQL++&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、解压缩文件&lt;/p&gt;
&lt;p&gt;3、进入mysql++-3.2.1\vc2008目录&lt;/p&gt;
&lt;p&gt;4、打开mysql++.
sln，让VS2010做自动转换，因为VS2010的工程配置目录改变了，因此VS2008的一些配置会丢失，因此需要手动添加mysql c connector的目录。同时只需要编译mysqlpp的lib，因此其他例子程序就编译了，所以下文只修改mysqlpp的工程目录。
5、默认的工程是编译x64的库，非常好编译，因此下文主要处理32位的情况。&lt;/p&gt;
&lt;p&gt;6、首先点击vs2010上方的x64，选择Configuration Manager，在active sulution 
platform选择new一个win32的配置，并复制x64的配置。然后把mysqlpp的platform改成win32。&lt;/p&gt;
&lt;p&gt;7、接着在工程中additional include directories添加mysql connector c的include路径。并且在preprocessor definitions 添加WIN32;_USRDLL;DLL_EXPORTS;_DEBUG;UNICODE;_UNICODE;MYSQLPP_MAKING_DLL;HAVE_MYSQL_SSL_SET;%(PreprocessorDefinitions)，这段宏定义可以在x64的相同位置找到。&lt;/p&gt;
&lt;p&gt;8、接着在mysqlpp工程中修改configuration type为 Dynamic Library；&lt;/p&gt;
&lt;p&gt;9、在mysqlpp工程中Linker-&amp;gt;General-&amp;gt;Additional Library Directories中添加C:\Program Files (x86)\MySQL\MySQL Connector C 6.1\lib，然后在Linker-&amp;gt;Input-&amp;gt;Additional Dependencies中添加libmysql.lib和wsock32.lib；&lt;/p&gt;
&lt;p&gt;10、最后一步需要修改工程的Runtime Library为MT的，进入C/C++-&amp;gt;Code Generation-&amp;gt;Runtime Library，修改为/MDd&lt;/p&gt;
&lt;p&gt;11、右键Solution Explorer点击mysqlpp点击build，即可生成mysqlpp.dll和mysqlpp.lib.&lt;/p&gt;
&lt;p&gt;12、Release版本的跟Debug类似，后续就不进行描述了。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Tue, 11 Feb 2014 00:00:00 +0100</pubDate><guid>tag:icylord.github.io,2014-02-11:compile-mysql-in-vs2010.html</guid><category>Computer Vision</category><category>Python</category></item><item><title>opencv_traincascade 代码阅读(apps/traincascade/boost.cpp)</title><link>http://icylord.github.io/opencv_traincascade-dai-ma-yue-du-appstraincascadeboostcpp.html</link><description>&lt;pre&gt;&lt;code&gt;
//每个Stage的训练函数
bool CvCascadeBoost::train( const CvFeatureEvaluator* _featureEvaluator,
                           int _numSamples,
                           int _precalcValBufSize, int _precalcIdxBufSize,
                           const CvCascadeBoostParams&amp; _params )
{
    bool isTrained = false;
    CV_Assert( !data );
    clear();
    // 准备CART tree的训练数据，其中包括预先计算所有训练样本的特征值
    data = new CvCascadeBoostTrainData( _featureEvaluator, _numSamples,
                                        _precalcValBufSize, _precalcIdxBufSize, _params );
    CvMemStorage *storage = cvCreateMemStorage();
    weak = cvCreateSeq( 0, sizeof(CvSeq), sizeof(CvBoostTree*), storage );
    storage = 0;

    set_params( _params );
    if ( (_params.boost_type == LOGIT) || (_params.boost_type == GENTLE) )
        data-&gt;do_responses_copy();

    update_weights( 0 ); // 首次设置训练样本的权重

    cout &lt;&lt; "+----+---------+---------+" &lt;&lt; endl;
    cout &lt;&lt; "|  N |    HR   |    FA   |" &lt;&lt; endl;
    cout &lt;&lt; "+----+---------+---------+" &lt;&lt; endl;

    do
    {
        CvCascadeBoostTree* tree = new CvCascadeBoostTree;
        if( !tree-&gt;train( data, subsample_mask, this ) )
        {
            delete tree;
            break;
        }
        cvSeqPush( weak, &amp;tree ); // 添加弱分类器
        update_weights( tree ); // 更新训练样本的权重
        trim_weights(); // 根据trim_weights剔除一部分训练样本
        if( cvCountNonZero(subsample_mask) == 0 )
            break;
    }
    while( !isErrDesired() &amp;&amp; (weak-&gt;total &lt; params.weak_count) ); // false alarm值达到预期或者弱分类器数目达到最大值，则停止迭代

    if(weak-&gt;total &gt; 0)
    {
        data-&gt;is_classifier = true;
        data-&gt;free_train_data();
        isTrained = true;
    }
    else
        clear();

    return isTrained;
}

// 每一级的强分类器停止迭代判断函数
bool CvCascadeBoost::isErrDesired()
{
    int sCount = data-&gt;sample_count,
        numPos = 0, numNeg = 0, numFalse = 0, numPosTrue = 0;
    vector&lt;float&gt; eval(sCount); // 保存分类器输出值

    for( int i = 0; i &lt; sCount; i++ )
        if( ((CvCascadeBoostTrainData*)data)-&gt;featureEvaluator-&gt;getCls( i ) == 1.0F )
            eval[numPos++] = predict( i, true ); // 计算所有正样本的输出值
    icvSortFlt( &amp;eval[0], numPos, 0 ); // 对正样本的输出值进行排序
    int thresholdIdx = (int)((1.0F - minHitRate) * numPos); // 根据minHitRate找出阈值
    threshold = eval[ thresholdIdx ];
    numPosTrue = numPos - thresholdIdx;
    for( int i = thresholdIdx - 1; i &gt;= 0; i--)
        if ( abs( eval[i] - threshold) &lt; FLT_EPSILON )
            numPosTrue++;
    float hitRate = ((float) numPosTrue) / ((float) numPos);

    for( int i = 0; i &lt; sCount; i++ )
    {
        if( ((CvCascadeBoostTrainData*)data)-&gt;featureEvaluator-&gt;getCls( i ) == 0.0F )
        {
            numNeg++;
            if( predict( i ) ) // 根据上面得到的阈值组成一个强分类器用于统计false alarm的数目
                numFalse++;
        }
    }
    float falseAlarm = ((float) numFalse) / ((float) numNeg);

    cout &lt;&lt; "|"; cout.width(4); cout &lt;&lt; right &lt;&lt; weak-&gt;total;
    cout &lt;&lt; "|"; cout.width(9); cout &lt;&lt; right &lt;&lt; hitRate;
    cout &lt;&lt; "|"; cout.width(9); cout &lt;&lt; right &lt;&lt; falseAlarm;
    cout &lt;&lt; "|" &lt;&lt; endl;
    cout &lt;&lt; "+----+---------+---------+" &lt;&lt; endl;

    return falseAlarm &lt;= maxFalseAlarm; // 如果false alarm并未达标，则返回 false
}


&lt;/code&gt;&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sat, 05 Oct 2013 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2013-10-05:opencv_traincascade-dai-ma-yue-du-appstraincascadeboostcpp.html</guid><category>Computer Vision</category><category>OpenCV</category></item><item><title>opencv_traincascade 代码阅读(apps/traincascade/cascadeclassifier.cpp)</title><link>http://icylord.github.io/opencv_traincascade-dai-ma-yue-du-appstraincascadecascadeclassifiercpp.html</link><description>&lt;pre&gt;&lt;code&gt;
级联分类器训练函数
bool CvCascadeClassifier::train( const string _cascadeDirName,
                                const string _posFilename,
                                const string _negFilename,
                                int _numPos, int _numNeg,
                                int _precalcValBufSize, int _precalcIdxBufSize,
                                int _numStages,
                                const CvCascadeParams&amp; _cascadeParams,
                                const CvFeatureParams&amp; _featureParams,
                                const CvCascadeBoostParams&amp; _stageParams,
                                bool baseFormatSave )
{
    if( _cascadeDirName.empty() || _posFilename.empty() || _negFilename.empty() )
        CV_Error( CV_StsBadArg, "_cascadeDirName or _bgfileName or _vecFileName is NULL" );

    string dirName;
    if (_cascadeDirName.find_last_of("/\\") == (_cascadeDirName.length() - 1) )
        dirName = _cascadeDirName;
    else
        dirName = _cascadeDirName + '/';

    numPos = _numPos;
    numNeg = _numNeg;
    numStages = _numStages;
    // 创建训练样本
    if ( !imgReader.create( _posFilename, _negFilename, _cascadeParams.winSize ) )
    {
        cout &lt;&lt; "Image reader can not be created from -vec " &lt;&lt; _posFilename
                &lt;&lt; " and -bg " &lt;&lt; _negFilename &lt;&lt; "." &lt;&lt; endl;
        return false;
    }
    if ( !load( dirName ) )
    {
        cascadeParams = _cascadeParams;
        featureParams = CvFeatureParams::create(cascadeParams.featureType);
        featureParams-&gt;init(_featureParams);
        stageParams = makePtr&lt;CvCascadeBoostParams&gt;();
        *stageParams = _stageParams;
        featureEvaluator = CvFeatureEvaluator::create(cascadeParams.featureType);
        featureEvaluator-&gt;init( featureParams, numPos + numNeg, cascadeParams.winSize );
        stageClassifiers.reserve( numStages );
    }
    cout &lt;&lt; "PARAMETERS:" &lt;&lt; endl;
    cout &lt;&lt; "cascadeDirName: " &lt;&lt; _cascadeDirName &lt;&lt; endl;
    cout &lt;&lt; "vecFileName: " &lt;&lt; _posFilename &lt;&lt; endl;
    cout &lt;&lt; "bgFileName: " &lt;&lt; _negFilename &lt;&lt; endl;
    cout &lt;&lt; "numPos: " &lt;&lt; _numPos &lt;&lt; endl;
    cout &lt;&lt; "numNeg: " &lt;&lt; _numNeg &lt;&lt; endl;
    cout &lt;&lt; "numStages: " &lt;&lt; numStages &lt;&lt; endl;
    cout &lt;&lt; "precalcValBufSize[Mb] : " &lt;&lt; _precalcValBufSize &lt;&lt; endl;
    cout &lt;&lt; "precalcIdxBufSize[Mb] : " &lt;&lt; _precalcIdxBufSize &lt;&lt; endl;
    cascadeParams.printAttrs();
    stageParams-&gt;printAttrs();
    featureParams-&gt;printAttrs();

    int startNumStages = (int)stageClassifiers.size();
    if ( startNumStages &gt; 1 )
        cout &lt;&lt; endl &lt;&lt; "Stages 0-" &lt;&lt; startNumStages-1 &lt;&lt; " are loaded" &lt;&lt; endl;
    else if ( startNumStages == 1)
        cout &lt;&lt; endl &lt;&lt; "Stage 0 is loaded" &lt;&lt; endl;

    double requiredLeafFARate = pow( (double) stageParams-&gt;maxFalseAlarm, (double) numStages ) /
                                (double)stageParams-&gt;max_depth;
    double tempLeafFARate;

    for( int i = startNumStages; i &lt; numStages; i++ )
    {
        cout &lt;&lt; endl &lt;&lt; "===== TRAINING " &lt;&lt; i &lt;&lt; "-stage =====" &lt;&lt; endl;
        cout &lt;&lt; "&lt;BEGIN" &lt;&lt; endl;

        if ( !updateTrainingSet( tempLeafFARate ) )
        {
            cout &lt;&lt; "Train dataset for temp stage can not be filled. "
                "Branch training terminated." &lt;&lt; endl;
            break;
        }
        if( tempLeafFARate &lt;= requiredLeafFARate )
        {
            cout &lt;&lt; "Required leaf false alarm rate achieved. "
                 "Branch training terminated." &lt;&lt; endl;
            break;
        }

        Ptr&lt;CvCascadeBoost&gt; tempStage = makePtr&lt;CvCascadeBoost&gt;();
        bool isStageTrained = tempStage-&gt;train( featureEvaluator,
                                                curNumSamples, _precalcValBufSize, _precalcIdxBufSize,
                                                *stageParams );
        cout &lt;&lt; "END&gt;" &lt;&lt; endl;

        if(!isStageTrained)
            break;

        stageClassifiers.push_back( tempStage );

        // save params
        if( i == 0) // 如果是第一级，则保存训练的参数
        {
            std::string paramsFilename = dirName + CC_PARAMS_FILENAME;
            FileStorage fs( paramsFilename, FileStorage::WRITE);
            if ( !fs.isOpened() )
            {
                cout &lt;&lt; "Parameters can not be written, because file " &lt;&lt; paramsFilename
                        &lt;&lt; " can not be opened." &lt;&lt; endl;
                return false;
            }
            fs &lt;&lt; FileStorage::getDefaultObjectName(paramsFilename) &lt;&lt; "{";
            writeParams( fs );
            fs &lt;&lt; "}";
        }
        // save current stage
        char buf[10];
        sprintf(buf, "%s%d", "stage", i );
        string stageFilename = dirName + buf + ".xml";
        FileStorage fs( stageFilename, FileStorage::WRITE );
        if ( !fs.isOpened() )
        {
            cout &lt;&lt; "Current stage can not be written, because file " &lt;&lt; stageFilename
                    &lt;&lt; " can not be opened." &lt;&lt; endl;
            return false;
        }
        fs &lt;&lt; FileStorage::getDefaultObjectName(stageFilename) &lt;&lt; "{";
        tempStage-&gt;write( fs, Mat() ); // 将中间的每级的分类器写入到目录中
        fs &lt;&lt; "}";
    }

    if(stageClassifiers.size() == 0)
    {
        cout &lt;&lt; "Cascade classifier can't be trained. Check the used training parameters." &lt;&lt; endl;
        return false;
    }

    save( dirName + CC_CASCADE_FILENAME, baseFormatSave );

    return true;
}

// boostrap 正负训练样本
int CvCascadeClassifier::fillPassedSamples( int first, int count, bool isPositive, int64&amp; consumed )
{
    int getcount = 0;
    Mat img(cascadeParams.winSize, CV_8UC1);
    for( int i = first; i &lt; first + count; i++ )
    {
        for( ; ; )
        {
            bool isGetImg = isPositive ? imgReader.getPos( img ) :
                                           imgReader.getNeg( img );
            if( !isGetImg )
                return getcount;
            consumed++;

            featureEvaluator-&gt;setImage( img, isPositive ? 1 : 0, i );
            if( predict( i ) == 1.0F ) // 如果predict为人脸，则加到训练集当中，这里如果人脸图像被判断为负的话，则剔除这些样本，使得训练简单一些，但是这些样本加进去训练得到的分类器是比不加进去要强的，仍旧推荐使用
            {
                getcount++;
                break;
            }
        }
    }
    return getcount;
}
&lt;/code&gt;&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sat, 05 Oct 2013 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2013-10-05:opencv_traincascade-dai-ma-yue-du-appstraincascadecascadeclassifiercpp.html</guid><category>Computer Vision</category><category>OpenCV</category></item><item><title>opencv_traincascade 代码阅读(ml/boost.cpp)</title><link>http://icylord.github.io/opencv_traincascade-dai-ma-yue-du-mlboostcpp.html</link><description>&lt;h1&gt;两个分支CART作为弱分类器太弱了 -____-!!!&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;
CvDTreeSplit*
CvBoostTree::find_split_cat_reg( CvDTreeNode* node, int vi, float init_quality, CvDTreeSplit* _split, uchar* _ext_buf )
{
    const double* weights = ensemble-&gt;get_subtree_weights()-&gt;data.db;
    int ci = data-&gt;get_var_type(vi);
    int n = node-&gt;sample_count;
    int mi = data-&gt;cat_count-&gt;data.i[ci];
    int base_size = (2*mi+3)*sizeof(double) + mi*sizeof(double*);
    cv::AutoBuffer&lt;uchar&gt; inn_buf(base_size);
    if( !_ext_buf )
        inn_buf.allocate(base_size + n*(2*sizeof(int) + sizeof(float)));
    uchar* base_buf = (uchar*)inn_buf;
    uchar* ext_buf = _ext_buf ? _ext_buf : base_buf + base_size;

    int* cat_labels_buf = (int*)ext_buf;
    const int* cat_labels = data-&gt;get_cat_var_data(node, vi, cat_labels_buf);
    float* responses_buf = (float*)(cat_labels_buf + n);
    int* sample_indices_buf = (int*)(responses_buf + n);
    const float* responses = data-&gt;get_ord_responses(node, responses_buf, sample_indices_buf);

    double* sum = (double*)cv::alignPtr(base_buf,sizeof(double)) + 1;
    double* counts = sum + mi + 1;
    double** sum_ptr = (double**)(counts + mi);
    double L = 0, R = 0, best_val = init_quality, lsum = 0, rsum = 0;
    int i, best_subset = -1, subset_i;

    for( i = -1; i &lt; mi; i++ ) // LBP对应 [0, 255]
        sum[i] = counts[i] = 0;

    // calculate sum response and weight of each category of the input var
    for( i = 0; i &lt; n; i++ )
    {
        int idx = ((cat_labels[i] == 65535) &amp;&amp; data-&gt;is_buf_16u) ? -1 : cat_labels[i];
        double w = weights[i]; // 样本的当前权重
        double s = sum[idx] + responses[i]*w; // 将样本的当前权重乘以类标(-1 or 1)累加到对应的idx里面，LBP对应 [0, 255]
        double nc = counts[idx] + w; // 将样本的权重累加
        sum[idx] = s;
        counts[idx] = nc;
    }

    // calculate average response in each category
    for( i = 0; i &lt; mi; i++ )
    {
        R += counts[i];
        rsum += sum[i];
        sum[i] = fabs(counts[i]) &gt; DBL_EPSILON ? sum[i]/counts[i] : 0; // 求出每个i里面的输出分数
        sum_ptr[i] = sum + i; //保存指针，用于根据sum的值进行排序
    }

    icvSortDblPtr( sum_ptr, mi, 0 );

    // revert back to unnormalized sums
    // (there should be a very little loss in accuracy)
    for( i = 0; i &lt; mi; i++ )
        sum[i] *= counts[i];

    // 求解CART回归树最优切分点代码
    for( subset_i = 0; subset_i &lt; mi-1; subset_i++ )
    {
        int idx = (int)(sum_ptr[subset_i] - sum); // 排序后第subset_i大的输出分数对应的sum下标
        double ni = counts[idx];

        if( ni &gt; FLT_EPSILON )
        {
            double s = sum[idx];
            lsum += s; L += ni;
            rsum -= s; R -= ni;

            if( L &gt; FLT_EPSILON &amp;&amp; R &gt; FLT_EPSILON )
            {
                double val = (lsum*lsum*R + rsum*rsum*L)/(L*R); //根据MBLBP论文Eq.2推出
                if( best_val &lt; val ) // 存在更优，则选择best_subset作为切分点
                {
                    best_val = val;
                    best_subset = subset_i;
                }
            }
        }
    }

    CvDTreeSplit* split = 0;
    if( best_subset &gt;= 0 )
    {
        split = _split ? _split : data-&gt;new_split_cat( 0, -1.0f);
        split-&gt;var_idx = vi;
        split-&gt;quality = (float)best_val;
        memset( split-&gt;subset, 0, (data-&gt;max_c_count + 31)/32 * sizeof(int));
        for( i = 0; i &lt;= best_subset; i++ ) // 以best_subset作为切分点，左边的送到左子树，右边的送到右子树
        {
            int idx = (int)(sum_ptr[i] - sum);
            split-&gt;subset[idx &gt;&gt; 5] |= 1 &lt;&lt; (idx &amp; 31);
        }
    }
    return split;
}
&lt;/code&gt;&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Fri, 04 Oct 2013 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2013-10-04:opencv_traincascade-dai-ma-yue-du-mlboostcpp.html</guid><category>Computer Vision</category><category>OpenCV</category></item><item><title>Install Numpy/Scipy with Intel MKL On MacOSX 10.8</title><link>http://icylord.github.io/install-numpyscipy-with-intel-mkl-on-macosx-108.html</link><description>&lt;h1&gt;First&lt;/h1&gt;
&lt;p&gt;Install Intel MKL(intel_cpp_comp_2013_mac)&lt;/p&gt;
&lt;p&gt;Download &lt;a href="http://sourceforge.net/projects/numpy/files/NumPy/"&gt;numpy&lt;/a&gt; and &lt;a href="http://sourceforge.net/projects/scipy/files/scipy/"&gt;scipy&lt;/a&gt; and unzip them.
&lt;pre&gt;&lt;code&gt;
unzip numpy-1.7.0.zip
unzip scipy-0.12.0.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Second&lt;/h1&gt;
&lt;p&gt;(1)modify numpy-1.7.0/numpy/distutils/site.cfg&lt;/p&gt;
&lt;p&gt;change line 143~146 to
&lt;pre&gt;&lt;code&gt;
library_dirs = /opt/intel/mkl/lib
include_dirs = /opt/intel/mkl/include
lapack_libs = mkl_lapack95
mkl_libs = mkl_rt
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(2)modify numpy-1.7.0/numpy/distutils/intelccompiler.py&lt;/p&gt;
&lt;p&gt;change line 37 to
&lt;pre&gt;&lt;code&gt;
self.cc_exe = 'icc -m64 -fPIC -O3 -g -fPIC -fp-model strict -fomit-frame-pointer -openmp -xhost -undefined dynamic_lookup -bundle -DMKL_ILP64' 
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(3) modify numpy-1.7.0/numpy/distutils/system_info.py&lt;/p&gt;
&lt;p&gt;change line 1448~1451 and add 
&lt;pre&gt;&lt;code&gt;
blas_mkl_info = get_info('blas_mkl')
        if blas_mkl_info:
            self.set_info(**blas_mkl_info)
            return
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;then change line 1360~1363 and add
&lt;pre&gt;&lt;code&gt;
lapack_mkl_info = get_info('lapack_mkl')
        if lapack_mkl_info:
            self.set_info(**lapack_mkl_info)
            return
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(4) compile numpy 
&lt;pre&gt;&lt;code&gt;
python setup.py config --compiler=intelem build_clib --compiler=intelem build_ext --compiler=intelem install
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Third&lt;/h1&gt;
&lt;p&gt;compile scipy
&lt;pre&gt;&lt;code&gt;
python setup.py config --compiler=intelem --fcompiler=intelem build_clib --compiler=intelem --fcompiler=intelem build_ext --compiler=intelem --fcompiler=intelem install
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Last&lt;/h1&gt;
&lt;p&gt;use this code to check the whether MKL is supported for numpy
&lt;pre&gt;&lt;code&gt;
import numpy as np &lt;br /&gt;
np.show_config()&lt;br /&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Tue, 10 Sep 2013 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2013-09-10:install-numpyscipy-with-intel-mkl-on-macosx-108.html</guid><category>Computer Vision</category><category>Python</category></item><item><title>SZU Face Detector Performance</title><link>http://icylord.github.io/szu-face-detector-performance.html</link><description>&lt;p&gt;Our new face detection algorithm(Shenzhen University Face Detector) reach &lt;strong&gt;state of the art&lt;/strong&gt;  on FDDB and AFW dataset.&lt;/p&gt;
&lt;p&gt;For FDDB result please refer to &lt;a href="http://vis-www.cs.umass.edu/fddb/results.html"&gt;FDDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For AFW result please refer to &lt;a href="http://www.ics.uci.edu/~xzhu/face"&gt;AFW&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/static/img/MV_FDDB_Disc_FPPI.png" height="480" width="640" alt="FDDB Result" /&gt;
&lt;img src="/static/img/MV_AFW_Disc_RP.png" height="480" width="640" alt="AFW Result" /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Tue, 10 Sep 2013 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2013-09-10:szu-face-detector-performance.html</guid><category>Computer Vision</category></item></channel></rss>