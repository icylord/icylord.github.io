<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>icylord's blog</title><link>http://icylord.github.io/</link><description></description><atom:link href="http://icylord.github.io/feeds/icylord.rss.xml" rel="self"></atom:link><lastBuildDate>Sun, 21 Sep 2014 00:00:00 +0200</lastBuildDate><item><title>libx264 x264_param_t</title><link>http://icylord.github.io/libx264-x264_param_t.html</link><description>&lt;h2&gt;libx264 x264_param_t&lt;/h2&gt;
&lt;h3&gt;转一个别人写好的libx264参数结构体x264_param_t的参数解析&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* 结构体x264_param_t定义在x264.h中 */&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;x264_param_t&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* CPU 标志位 */&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_threads&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 并行编码多帧; 线程数，为0则自动多线程编码&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_sliced_threads&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 如果为false，则一个slice只编码成一个NALU;&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 否则有几个线程，在编码成几个NALU。缺省为true。&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_deterministic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 是否允许非确定性时线程优化&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_cpu_independent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 强制采用典型行为，而不是采用独立于cpu的优化算法&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_sync_lookahead&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 线程超前缓存帧数&lt;/span&gt;

    &lt;span class="cm"&gt;/* 视频属性 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_width&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 视频图像的宽&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_height&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 视频图像的高&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_csp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                     &lt;span class="c1"&gt;// 编码比特流的CSP，仅支持i420，色彩空间设置&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_level_idc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 指明作用的level值，可能与编码复杂度有关&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_frame_total&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 编码帧的总数, 默认 0&lt;/span&gt;

    &lt;span class="cm"&gt;/* hrd : hypothetical reference decoder (假定参考解码器) , 检验编码器产生的符合&lt;/span&gt;
&lt;span class="cm"&gt;      该标准的NAL单元流或字节流的偏差值。蓝光视频、电视广播及其它特殊领域有此要求 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_nal_hrd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* vui参数集 : 视频可用性信息、视频标准化选项 */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* 宽高比的两个值相对互素，且在(0,  65535] 之间 */&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_sar_height&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 样本宽高比的高度&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_sar_width&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 样本宽高比的宽度&lt;/span&gt;

    &lt;span class="cm"&gt;/* 0=undef, 1=no overscan, 2=overscan 过扫描线，&lt;/span&gt;
&lt;span class="cm"&gt;        默认&amp;quot;undef&amp;quot;(不设置)，可选项：show(观看) / crop(去除) */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_overscan&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 以下的值可以参见H264附录E */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_vidformat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 视频在编码/数字化之前是什么类型，默认&amp;quot;undef&amp;quot;.&lt;/span&gt;
                                &lt;span class="c1"&gt;// 取值有：Component, PAL, NTSC, SECAM, MAC 等&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_fullrange&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 样本亮度和色度的计算方式，默认&amp;quot;off&amp;quot;，可选项：off/on&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_colorprim&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 原始色度格式，默认&amp;quot;undef&amp;quot;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_transfer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 转换方式，默认&amp;quot;undef&amp;quot;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_colmatrix&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 设置从RGB计算得到亮度和色度所用的矩阵系数，默认&amp;quot;undef&amp;quot;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_chroma_loc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 设置色度采样位置，范围0~5，默认0&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;vui&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 比特流参数 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_frame_reference&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 最大参考帧数目&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_dpb_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// Decoded picture buffer size&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_keyint_max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 设定IDR帧之间的最间隔，在此间隔设置IDR关键帧&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_keyint_min&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 设定IDR帧之间的最小间隔, 场景切换小于此值编码位I帧, 而不是 IDR帧.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_scenecut_threshold&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 场景切换阈值，插入I帧&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_intra_refresh&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 是否使用周期帧内刷新替代IDR帧&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_bframe&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 两个参考帧之间的B帧数目&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_bframe_adaptive&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 自适应B帧判定, 可选取值：X264_B_ADAPT_FAST等&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_bframe_bias&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 控制B帧替代P帧的概率，范围-100 ~ +100，&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 该值越高越容易插入B帧，默认0.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_bframe_pyramid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 允许部分B帧为参考帧，&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 可选取值：0=off,  1=strict hierarchical,  2=normal&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_open_gop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// Close GOP是指帧间的预测都是在GOP中进行的。&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 使用Open GOP，后一个GOP会参考前一个GOP的信息。&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_bluray_compat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 支持蓝光碟&lt;/span&gt;

    &lt;span class="cm"&gt;/* 去块滤波器需要的参数, alpha和beta是去块滤波器参数 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_deblocking_filter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 去块滤波开关&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_deblocking_filter_alphac0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// [-6, 6] -6 light filter, 6 strong&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_deblocking_filter_beta&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// [-6, 6] 同上&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_cabac&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// 自适应算术编码cabac开关&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_cabac_init_idc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 给出算术编码初始化时表格的选择&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_interlaced&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 隔行扫描&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_constrained_intra&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

     &lt;span class="cm"&gt;/* 量化 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_cqm_preset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 自定义量化矩阵(CQM), 初始化量化模式为flat&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz_cqm_file&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 读取JM格式的外部量化矩阵文件，忽略其他cqm选项&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_4iy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;           &lt;span class="c1"&gt;// used only if i_cqm_preset == X264_CQM_CUSTOM   &lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_4py&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_4ic&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_4pc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_8iy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_8py&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_8ic&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;cqm_8pc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="cm"&gt;/* 日志 */&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pf_log&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i_level&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;va_list&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// 日志函数&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt;  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p_log_private&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;    &lt;span class="n"&gt;i_log_level&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 日志级别，不需要打印编码信息时直接注释掉即可&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;    &lt;span class="n"&gt;b_visualize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 是否显示日志&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt;   &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz_dump_yuv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;//  重建帧的文件名&lt;/span&gt;

    &lt;span class="cm"&gt;/* 编码分析参数 */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;intra&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;//  帧内分区&lt;/span&gt;
        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;inter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;//  帧间分区&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_transform_8x8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// &lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_weighted_pred&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// P帧权重&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_weighted_bipred&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// B帧隐式加权&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_direct_mv_pred&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 时间空间运动向量预测模式&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_chroma_qp_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 色度量化步长偏移量&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_me_method&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 运动估计算法 (X264_ME_*)&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_me_range&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 整像素运动估计搜索范围 (from predicted mv) &lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_mv_range&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 运动矢量最大长度. -1 = auto, based on level&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_mv_range_thread&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 线程之间的最小运动向量缓冲.  -1 = auto, based on number of threads.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_subpel_refine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 亚像素运动估计质量&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_chroma_me&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 亚像素色度运动估计和P帧的模式选择&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_mixed_references&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 允许每个宏块的分区有它自己的参考号&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_trellis&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// Trellis量化提高效率，对每个8x8的块寻找合适的量化值，需要CABAC，&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 0 ：即关闭  1：只在最后编码时使用  2：在所有模式决策上启用&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_fast_pskip&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 快速P帧跳过检测&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_dct_decimate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// P帧变换系数阈值&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_noise_reduction&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 自适应伪盲区&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_psy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                     &lt;span class="c1"&gt;// Psy优化开关，可能会增强细节&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_psy_rd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// Psy RD强度&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_psy_trellis&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// Psy Trellis强度&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_luma_deadzone&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;        &lt;span class="c1"&gt;// 亮度量化中使用的盲区大小，{ 帧间, 帧内 }&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_psnr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// 计算和打印PSNR信息&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_ssim&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// 计算和打印SSIM信息&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;analyse&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 码率控制参数 */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_rc_method&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 码率控制方式 ： X264_RC_CQP恒定质量,  &lt;/span&gt;
                                    &lt;span class="c1"&gt;// X264_RC_CRF恒定码率,  X264_RC_ABR平均码率&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_qp_constant&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 指定P帧的量化值，0 - 51，0表示无损&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_qp_min&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 允许的最小量化值，默认10&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_qp_max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 允许的最大量化值，默认51&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_qp_step&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 量化步长，即相邻两帧之间量化值之差的最大值&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;i_bitrate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 平均码率大小&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_rf_constant&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 1pass VBR, nominal QP. 实际质量，值越大图像越花,越小越清晰&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_rf_constant_max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 最大码率因子，该选项仅在使用CRF并开启VBV时有效，&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 图像质量的最大值，可能会导致VBV下溢。&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_rate_tolerance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 允许的误差&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;    &lt;span class="n"&gt;i_vbv_max_bitrate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 平均码率模式下，最大瞬时码率，默认0&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;    &lt;span class="n"&gt;i_vbv_buffer_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 码率控制缓冲区的大小，单位kbit，默认0&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_vbv_buffer_init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 设置码率控制缓冲区（VBV）缓冲达到多满(百分比)，才开始回放，&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 范围0~1.0，默认0.9&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_ip_factor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// I帧和P帧之间的量化因子（QP）比值，默认1.4&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_pb_factor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// P帧和B帧之间的量化因子（QP）比值，默认1.3&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;i_aq_mode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 自适应量化（AQ）模式。 0：关闭AQ  &lt;/span&gt;
                                    &lt;span class="c1"&gt;// 1：允许AQ在整个视频中和帧内重新分配码&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 2：自方差AQ(实验阶段)，尝试逐帧调整强度&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_aq_strength&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// AQ强度，减少平趟和纹理区域的块效应和模糊度&lt;/span&gt;

    &lt;span class="cm"&gt;/* MBTree File是一个临时文件，记录了每个P帧中每个MB被参考的情况。&lt;/span&gt;
&lt;span class="cm"&gt;      目前mbtree只处理P帧的MB，同时也不支持b_pyramid. */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;b_mb_tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 是否开启基于macroblock的qp控制方法&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;i_lookahead&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 决定mbtree向前预测的帧数&lt;/span&gt;

    &lt;span class="cm"&gt;/* 2pass */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;b_stat_write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 是否将统计数据写入到文件psz_stat_out中&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt;  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz_stat_out&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 输出文件用于保存第一次编码统计数据&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;   &lt;span class="n"&gt;b_stat_read&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 是否从文件psz_stat_in中读入统计数据&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt;  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz_stat_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 输入文件存有第一次编码的统计数据&lt;/span&gt;

    &lt;span class="cm"&gt;/* 2pass params (same as ffmpeg ones) */&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_qcompress&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 量化曲线(quantizer curve)压缩因子。&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 0.0 =&amp;gt; 恒定比特率，1.0 =&amp;gt; 恒定量化值。&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_qblur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 时间上模糊量化，减少QP的波动(after curve compression)&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt;  &lt;span class="n"&gt;f_complexity_blur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 时间上模糊复杂性，减少QP的波动(before curve compression)&lt;/span&gt;
    &lt;span class="kt"&gt;x264_zone_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;zones&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 码率控制覆盖&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;    &lt;span class="n"&gt;i_zones&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// number of zone_t&amp;#39;s&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt;  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;psz_zones&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 指定区的另一种方法&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 裁剪矩形窗口参数：隐式添加到分辨率非16倍数的视频中 */&lt;/span&gt;
    &lt;span class="cm"&gt;/* 在码流层指定一个切除(crop)矩形。若不想x264在编码时做crop，&lt;/span&gt;
&lt;span class="cm"&gt;       但希望解码器在回放时进行切除，可使用此项。单位为像素。 */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i_left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i_top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i_right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i_bottom&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;crop_rect&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 编码3D视频时，此参数在码流中插入一个标志，告知解码器此3D视频是如何封装&lt;/span&gt;
&lt;span class="cm"&gt;      的。3D视频帧封装格式：帧封装、场交错、线交错、左右全景、左右半景、上下半&lt;/span&gt;
&lt;span class="cm"&gt;      景、L+深度、L+深度+图形+图形深度 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_frame_packing&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* Muxing复用参数 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_aud&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                     &lt;span class="c1"&gt;// 生成访问单元分隔符&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_repeat_headers&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 是否复制sps和pps放在每个关键帧的前面&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_annexb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 值为true，则NALU之前是4字节前缀码0x00000001；&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 值为false，则NALU之前的4个字节为NALU长度&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_sps_id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// sps和pps的id号&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_vfr_input&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// VFR输入。1 ：时间基和时间戳用于码率控制  0 ：仅帧率用于码率控制&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt;  &lt;span class="n"&gt;i_fps_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 帧率的分子&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt;  &lt;span class="n"&gt;i_fps_den&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 帧率的分母&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt;  &lt;span class="n"&gt;i_timebase_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 时间基的分子&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt;  &lt;span class="n"&gt;i_timebase_den&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 时间基的分母&lt;/span&gt;

    &lt;span class="cm"&gt;/* 以某个预设模式将输入流(隔行，恒定帧率)标记为软交错(soft telecine)。默认none. 可用预设有：&lt;/span&gt;
&lt;span class="cm"&gt;      none, 22, 32, 64, double, triple, euro.  使用除none以外任一预设，都会连带开启--pic-struct */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_pulldown&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;b_pic_struct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 强制在Picture Timing SEI传送pic_struct. 默认是未开启&lt;/span&gt;

    &lt;span class="cm"&gt;/* 将视频流标记为交错(隔行)，哪怕并非为交错式编码。可用于编码蓝光兼容的25p和30p视频。默认是未开启 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b_fake_interlaced&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 条带参数 */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_slice_max_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 每个slice的最大字节数，包括预计的NAL开销&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_slice_max_mbs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 每个slice的最大宏块数，重写i_slice_count&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;i_slice_count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 每帧slice的数目，每个slice必须是矩形&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="kt"&gt;x264_param_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sun, 21 Sep 2014 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2014-09-21:libx264-x264_param_t.html</guid><category>H.264</category></item><item><title>Implement virtual camera on Windows 7 using DirectShow</title><link>http://icylord.github.io/implement-virtual-camera-on-windows-7-using-directshow.html</link><description>&lt;h2&gt;Windows7下使用Directshow实现虚拟摄像头&lt;/h2&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;近期碰到了个项目，破解了某个摄像头设备的视频数据流到PC的方法(Linux+RTSP Streaming -&amp;gt; PC -&amp;gt; Virtual Camera -&amp;gt; Skype/Link/QQ)，打算扔掉这个设备自带的驱动，自己写一个，需要在Windows平台下实现一个虚拟摄像头，使得Skype、QQ等聊天软件能够使用远端的Web Camera设备的视频数据作为输入端进行视频聊天，在网上搜刮了一番资料后，花了点时间将其实现了。近期有时间，就把整个实现方法和过程写下来方便以后回顾&lt;/p&gt;
&lt;p&gt;在进行之前首先需要知道什么是&lt;strong&gt;DirectShow&lt;/strong&gt;和&lt;strong&gt;DirectShow filter。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DirectShow&lt;/strong&gt;（摘自wikipedia）：DirectShow (sometimes abbreviated as DS or DShow), codename Quartz, is a multimedia framework and API produced by Microsoft for software developers to perform various operations with media files or streams. It is the replacement for Microsoft's earlier Video for Windows technology. &lt;strong&gt;Based on the Microsoft Windows Component Object Model (COM) framework, DirectShow provides a common interface for media across various programming languages, and is an extensible, filter-based framework that can render or record media files on demand at the request of the user or developer&lt;/strong&gt;. 也就是说，DirectShow为多媒体流的捕捉和回放提供了强而有力的支持。 通过DirectShow，我们可以很方便地从支持WDM驱动模型的采集卡上采集数据，并进行相应的后期处理乃至存储到文件当中。DirectShow是一种开放式的开发环境，我们可以根据自己的需求定制自己的组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DirectShow Filter&lt;/strong&gt;（摘自MSDN）：DirectShow provides a set of default filters in Windows. &lt;strong&gt;These filters support many data formats while providing a high degree of hardware independence&lt;/strong&gt;. An application can also register and install custom filters on the target system. DirectShow是基于模块化的，每个功能模块采取COM组件的方式，成为Filter。Filter是DirectShow的最基本的概念。DirectShow使用Filter Graph来管理Filter。Filter Graph是Filter的“容器”，而Filter是Filter Graph的最小功能模块。粗略地说，可以认为Filter是一个插件。 我们可以自定义实现Filter提供给Filter Graph来使用达到我们特殊的应用目的。&lt;/p&gt;
&lt;p&gt;DirectShow Filter包括&lt;strong&gt;Source Filter&lt;/strong&gt;、&lt;strong&gt;Transform Filter&lt;/strong&gt;和&lt;strong&gt;Render Filter&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Windows平台下，常见的聊天软件都是使用DirectShow获取摄像头并得到图像数据的，因此若要实现一个虚拟摄像头的功能，DirectShow是必不可少的。 至于DirectShow Filter，因为在需要实现的虚拟摄像头的功能中，图像的输入数据并不是直接由摄像头的提供方提供的驱动得到硬件设备数据，而是我们自己提供的数据，比如可以使本地的视频文件，或者是远端的图像数据。 微软提供了DirectShow Filter这种框架可以方便开发者进行自定义的数据输入的功能，当然，这只是DirectShow Filter能够做到的众多功能其中之一。 本文使用的是DirectShow Filter中的其中的Source Filter。&lt;/p&gt;
&lt;p&gt;下面给出一张实现了需要摄像头后，QQ选取摄像头设备的效果图，其中Virtual Camera为虚拟的设备：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/static/img/virtualcameraselection.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;实现虚拟摄像头需要进行如下步骤：&lt;/p&gt;
&lt;p&gt;（1）实现DLL注册函数，使得虚拟的设备能够在聊天软件或者VLC等软件在DShow列表中选取；&lt;/p&gt;
&lt;p&gt;（2）实现DirectShow Source Filter，包括得到图像输入数据，转换成标准的输出格式，提供给调用此Source filter的调用对象；&lt;/p&gt;
&lt;p&gt;（3）将生成的Dll文件注册到系统注册表中。&lt;/p&gt;
&lt;h3&gt;下面按照步骤逐一介绍实现方法&lt;/h3&gt;
&lt;h3&gt;第一部分&lt;/h3&gt;
&lt;p&gt;Filter是一个基于Dll的COM组件，一般Filter需要实现下面几个入口函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DllMain&lt;/li&gt;
&lt;li&gt;DllRegisterServer&lt;/li&gt;
&lt;li&gt;DllUnregisterServer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体可以参考DirectShow自带的Ball例子。需要注意的是，要使得设备能够被DirectShow选取到，则需要额外实现将Dll注册为CLSID_VideoInputDeviceCategory的函数。见下面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;STDAPI&lt;/span&gt; &lt;span class="nf"&gt;DllRegisterServer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;RegisterFilters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;STDAPI&lt;/span&gt; &lt;span class="nf"&gt;DllUnregisterServer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;RegisterFilters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;WINAPI&lt;/span&gt; &lt;span class="n"&gt;DllEntryPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HINSTANCE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ULONG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LPVOID&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;APIENTRY&lt;/span&gt; &lt;span class="nf"&gt;DllMain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HANDLE&lt;/span&gt; &lt;span class="n"&gt;hModule&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                      &lt;span class="n"&gt;DWORD&lt;/span&gt;  &lt;span class="n"&gt;dwReason&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                      &lt;span class="n"&gt;LPVOID&lt;/span&gt; &lt;span class="n"&gt;lpReserved&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;DllEntryPoint&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;HINSTANCE&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;hModule&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;dwReason&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lpReserved&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;STDAPI&lt;/span&gt; &lt;span class="nf"&gt;RegisterFilters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;bRegister&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NOERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;WCHAR&lt;/span&gt; &lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_PATH&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_PATH&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;ASSERT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g_hInst&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;GetModuleFileNameA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g_hInst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; 
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;AmHresultFromWin32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GetLastError&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;MultiByteToWideChar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CP_ACP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lstrlenA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
        &lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NUMELMS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CoInitialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bRegister&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// The AMovieDllRegisterServer2 function creates registry entries for every component in the g_Templates&lt;/span&gt;
        &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AMovieSetupRegisterServer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;g_wszName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;L&amp;quot;Both&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;L&amp;quot;InprocServer32&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUCCEEDED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;IFilterMapper2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pFM2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CoCreateInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_FilterMapper2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CLSCTX_INPROC_SERVER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;IID_IFilterMapper2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUCCEEDED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bRegister&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;IMoniker&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pMoniker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;RegisterFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;g_wszName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pMoniker&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;CLSID_VideoInputDeviceCategory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rf2FilterReg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;UnregisterFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;CLSID_VideoInputDeviceCategory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;// release interface&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Release&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUCCEEDED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;bRegister&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AMovieSetupUnregisterServer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;CoFreeUnusedLibraries&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;CoUninitialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中CLSID_VirtualCamera为我们自己生成的GUID，每个COM组件使用一个唯一的GUID来标识，当创建一个COM组件的时候，都是首先通过该ID调用CoCreateInstance函数来创建对应的组件类工厂。我们可以使用自带软件GUID Generator生成，见图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/static/img/guid.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;生成后，将Result部分贴到源代码当中，并将name修改成我们自定义的名称，比如CLSID_VirtualCamera&lt;/p&gt;
&lt;p&gt;按照上述，将编译好的Dll进行注册，那么应该可以在聊天软件中的下拉列表看到我们虚拟出来的设备名称了。前提是已经实现了Source Filter，否则会编译不过的，呵呵。因为关键的Filter类还没有实现！&lt;/p&gt;
&lt;h3&gt;第二部分&lt;/h3&gt;
&lt;p&gt;Source Filter的实现
关键是需要实现继承CSource和CSourceStream这两个类，并实现相关的接口，列举如下：&lt;/p&gt;
&lt;p&gt;其中CSourceStream的子类必须继承IAMStreamConfig, IKsPropertySet这两个接口&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;VirtualCamera&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;CSource&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;

    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;CUnknown&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;WINAPI&lt;/span&gt; &lt;span class="n"&gt;CreateInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LPUNKNOWN&lt;/span&gt; &lt;span class="n"&gt;lpunk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;QueryInterface&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFIID&lt;/span&gt; &lt;span class="n"&gt;riid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;ppv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;IFilterGraph&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;GetGraph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;m_pGraph&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;

    &lt;span class="c1"&gt;// It is only allowed to to create these objects with CreateInstance&lt;/span&gt;
    &lt;span class="n"&gt;VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LPUNKNOWN&lt;/span&gt; &lt;span class="n"&gt;lpunk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;Stop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;VirtualCameraStream&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;CSourceStream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IAMStreamConfig&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IKsPropertySet&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="nl"&gt;public:&lt;/span&gt;

    &lt;span class="n"&gt;VirtualCameraStream&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;VirtualCamera&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pParent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LPCWSTR&lt;/span&gt; &lt;span class="n"&gt;pPinName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;VirtualCameraStream&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// plots a ball into the supplied video frame&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;FillBuffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IMediaSample&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pms&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Ask for buffers of the size appropriate to the agreed media type&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;DecideBufferSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IMemAllocator&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pIMemAlloc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                             &lt;span class="n"&gt;ALLOCATOR_PROPERTIES&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pProperties&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Set the agreed media type, and set up the necessary ball parameters&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;SetMediaType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CMediaType&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pMediaType&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Because we calculate the ball there is no reason why we&lt;/span&gt;
    &lt;span class="c1"&gt;// can&amp;#39;t calculate it in any one of a set of formats...&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;CheckMediaType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CMediaType&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pMediaType&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;GetMediaType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;iPosition&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CMediaType&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pmt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Resets the stream time to zero&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;OnThreadCreate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Quality control notifications sent to us&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;Notify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IBaseFilter&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pSender&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Quality&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//  IUnknown&lt;/span&gt;
    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;QueryInterface&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFIID&lt;/span&gt; &lt;span class="n"&gt;riid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;ppv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ULONG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;AddRef&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GetOwner&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;AddRef&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ULONG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;Release&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GetOwner&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Release&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//  IAMStreamConfig&lt;/span&gt;
    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="n"&gt;SetFormat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AM_MEDIA_TYPE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pmt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;GetFormat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AM_MEDIA_TYPE&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;ppmt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;GetNumberOfCapabilities&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;piCount&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;piSize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;GetStreamCaps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;iIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AM_MEDIA_TYPE&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;pmt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BYTE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pSCC&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//  IKsPropertySet&lt;/span&gt;
    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFGUID&lt;/span&gt; &lt;span class="n"&gt;guidPropSet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;dwID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pPropData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbPropData&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;Get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFGUID&lt;/span&gt; &lt;span class="n"&gt;guidPropSet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;dwPropID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pPropData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbPropData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pcbReturned&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;QuerySupported&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFGUID&lt;/span&gt; &lt;span class="n"&gt;guidPropSet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;dwPropID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pTypeSupport&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nl"&gt;private:&lt;/span&gt;
    &lt;span class="n"&gt;CCritSec&lt;/span&gt; &lt;span class="n"&gt;shared_state_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// Lock on shared_state_&lt;/span&gt;
    &lt;span class="n"&gt;CRefTime&lt;/span&gt; &lt;span class="n"&gt;sample_time_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// The time stamp for each sample&lt;/span&gt;
    &lt;span class="n"&gt;VirtualCamera&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;此部分持续更新&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;第三部分&lt;/h3&gt;
&lt;p&gt;实现完毕并且编译得到的Filter Dll需要注册到注册表中，才得到我们能够选取到的虚拟摄像头。 Filter本身是种COM组件，一般使用regsvr32.exe将其注册到注册表中。具体用法为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册：regsvr32.exe XXX.dll&lt;/li&gt;
&lt;li&gt;反注册： regsvr32.exe -u XXX.dll&lt;/li&gt;
&lt;li&gt;如果想取消注册完成的弹出提示窗口，可以再regsvr32.exe之后加上-s参数&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Tue, 01 Jul 2014 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2014-07-01:implement-virtual-camera-on-windows-7-using-directshow.html</guid><category>Directshow</category></item><item><title>Compile MYSQL++ in VS2010</title><link>http://icylord.github.io/compile-mysql-in-vs2010.html</link><description>&lt;p&gt;1、到http://tangentsoft.net/mysql++/下载mysql++-3.2.1 &lt;/p&gt;
&lt;p&gt;链接:&lt;a href="http://tangentsoft.net/mysql++/releases/mysql++-3.2.1.tar.gz"&gt;MYSQL++&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、解压缩文件&lt;/p&gt;
&lt;p&gt;3、进入mysql++-3.2.1\vc2008目录&lt;/p&gt;
&lt;p&gt;4、打开mysql++.
sln，让VS2010做自动转换，因为VS2010的工程配置目录改变了，因此VS2008的一些配置会丢失，因此需要手动添加mysql c connector的目录。同时只需要编译mysqlpp的lib，因此其他例子程序就编译了，所以下文只修改mysqlpp的工程目录。
5、默认的工程是编译x64的库，非常好编译，因此下文主要处理32位的情况。&lt;/p&gt;
&lt;p&gt;6、首先点击vs2010上方的x64，选择Configuration Manager，在active sulution 
platform选择new一个win32的配置，并复制x64的配置。然后把mysqlpp的platform改成win32。&lt;/p&gt;
&lt;p&gt;7、接着在工程中additional include directories添加mysql connector c的include路径。并且在preprocessor definitions 添加WIN32;_USRDLL;DLL_EXPORTS;_DEBUG;UNICODE;_UNICODE;MYSQLPP_MAKING_DLL;HAVE_MYSQL_SSL_SET;%(PreprocessorDefinitions)，这段宏定义可以在x64的相同位置找到。&lt;/p&gt;
&lt;p&gt;8、接着在mysqlpp工程中修改configuration type为 Dynamic Library；&lt;/p&gt;
&lt;p&gt;9、在mysqlpp工程中Linker-&amp;gt;General-&amp;gt;Additional Library Directories中添加C:\Program Files (x86)\MySQL\MySQL Connector C 6.1\lib，然后在Linker-&amp;gt;Input-&amp;gt;Additional Dependencies中添加libmysql.lib和wsock32.lib；&lt;/p&gt;
&lt;p&gt;10、最后一步需要修改工程的Runtime Library为MT的，进入C/C++-&amp;gt;Code Generation-&amp;gt;Runtime Library，修改为/MDd&lt;/p&gt;
&lt;p&gt;11、右键Solution Explorer点击mysqlpp点击build，即可生成mysqlpp.dll和mysqlpp.lib.&lt;/p&gt;
&lt;p&gt;12、Release版本的跟Debug类似，后续就不进行描述了。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Tue, 11 Feb 2014 00:00:00 +0100</pubDate><guid>tag:icylord.github.io,2014-02-11:compile-mysql-in-vs2010.html</guid><category>Computer Vision</category><category>Python</category></item><item><title>opencv_traincascade 代码阅读(apps/traincascade/boost.cpp)</title><link>http://icylord.github.io/opencv_traincascade-dai-ma-yue-du-appstraincascadeboostcpp.html</link><description>&lt;pre&gt;&lt;code&gt;
//每个Stage的训练函数
bool CvCascadeBoost::train( const CvFeatureEvaluator* _featureEvaluator,
                           int _numSamples,
                           int _precalcValBufSize, int _precalcIdxBufSize,
                           const CvCascadeBoostParams&amp; _params )
{
    bool isTrained = false;
    CV_Assert( !data );
    clear();
    // 准备CART tree的训练数据，其中包括预先计算所有训练样本的特征值
    data = new CvCascadeBoostTrainData( _featureEvaluator, _numSamples,
                                        _precalcValBufSize, _precalcIdxBufSize, _params );
    CvMemStorage *storage = cvCreateMemStorage();
    weak = cvCreateSeq( 0, sizeof(CvSeq), sizeof(CvBoostTree*), storage );
    storage = 0;

    set_params( _params );
    if ( (_params.boost_type == LOGIT) || (_params.boost_type == GENTLE) )
        data-&gt;do_responses_copy();

    update_weights( 0 ); // 首次设置训练样本的权重

    cout &lt;&lt; "+----+---------+---------+" &lt;&lt; endl;
    cout &lt;&lt; "|  N |    HR   |    FA   |" &lt;&lt; endl;
    cout &lt;&lt; "+----+---------+---------+" &lt;&lt; endl;

    do
    {
        CvCascadeBoostTree* tree = new CvCascadeBoostTree;
        if( !tree-&gt;train( data, subsample_mask, this ) )
        {
            delete tree;
            break;
        }
        cvSeqPush( weak, &amp;tree ); // 添加弱分类器
        update_weights( tree ); // 更新训练样本的权重
        trim_weights(); // 根据trim_weights剔除一部分训练样本
        if( cvCountNonZero(subsample_mask) == 0 )
            break;
    }
    while( !isErrDesired() &amp;&amp; (weak-&gt;total &lt; params.weak_count) ); // false alarm值达到预期或者弱分类器数目达到最大值，则停止迭代

    if(weak-&gt;total &gt; 0)
    {
        data-&gt;is_classifier = true;
        data-&gt;free_train_data();
        isTrained = true;
    }
    else
        clear();

    return isTrained;
}

// 每一级的强分类器停止迭代判断函数
bool CvCascadeBoost::isErrDesired()
{
    int sCount = data-&gt;sample_count,
        numPos = 0, numNeg = 0, numFalse = 0, numPosTrue = 0;
    vector&lt;float&gt; eval(sCount); // 保存分类器输出值

    for( int i = 0; i &lt; sCount; i++ )
        if( ((CvCascadeBoostTrainData*)data)-&gt;featureEvaluator-&gt;getCls( i ) == 1.0F )
            eval[numPos++] = predict( i, true ); // 计算所有正样本的输出值
    icvSortFlt( &amp;eval[0], numPos, 0 ); // 对正样本的输出值进行排序
    int thresholdIdx = (int)((1.0F - minHitRate) * numPos); // 根据minHitRate找出阈值
    threshold = eval[ thresholdIdx ];
    numPosTrue = numPos - thresholdIdx;
    for( int i = thresholdIdx - 1; i &gt;= 0; i--)
        if ( abs( eval[i] - threshold) &lt; FLT_EPSILON )
            numPosTrue++;
    float hitRate = ((float) numPosTrue) / ((float) numPos);

    for( int i = 0; i &lt; sCount; i++ )
    {
        if( ((CvCascadeBoostTrainData*)data)-&gt;featureEvaluator-&gt;getCls( i ) == 0.0F )
        {
            numNeg++;
            if( predict( i ) ) // 根据上面得到的阈值组成一个强分类器用于统计false alarm的数目
                numFalse++;
        }
    }
    float falseAlarm = ((float) numFalse) / ((float) numNeg);

    cout &lt;&lt; "|"; cout.width(4); cout &lt;&lt; right &lt;&lt; weak-&gt;total;
    cout &lt;&lt; "|"; cout.width(9); cout &lt;&lt; right &lt;&lt; hitRate;
    cout &lt;&lt; "|"; cout.width(9); cout &lt;&lt; right &lt;&lt; falseAlarm;
    cout &lt;&lt; "|" &lt;&lt; endl;
    cout &lt;&lt; "+----+---------+---------+" &lt;&lt; endl;

    return falseAlarm &lt;= maxFalseAlarm; // 如果false alarm并未达标，则返回 false
}


&lt;/code&gt;&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sat, 05 Oct 2013 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2013-10-05:opencv_traincascade-dai-ma-yue-du-appstraincascadeboostcpp.html</guid><category>Computer Vision</category><category>OpenCV</category></item><item><title>opencv_traincascade 代码阅读(apps/traincascade/cascadeclassifier.cpp)</title><link>http://icylord.github.io/opencv_traincascade-dai-ma-yue-du-appstraincascadecascadeclassifiercpp.html</link><description>&lt;pre&gt;&lt;code&gt;
级联分类器训练函数
bool CvCascadeClassifier::train( const string _cascadeDirName,
                                const string _posFilename,
                                const string _negFilename,
                                int _numPos, int _numNeg,
                                int _precalcValBufSize, int _precalcIdxBufSize,
                                int _numStages,
                                const CvCascadeParams&amp; _cascadeParams,
                                const CvFeatureParams&amp; _featureParams,
                                const CvCascadeBoostParams&amp; _stageParams,
                                bool baseFormatSave )
{
    if( _cascadeDirName.empty() || _posFilename.empty() || _negFilename.empty() )
        CV_Error( CV_StsBadArg, "_cascadeDirName or _bgfileName or _vecFileName is NULL" );

    string dirName;
    if (_cascadeDirName.find_last_of("/\\") == (_cascadeDirName.length() - 1) )
        dirName = _cascadeDirName;
    else
        dirName = _cascadeDirName + '/';

    numPos = _numPos;
    numNeg = _numNeg;
    numStages = _numStages;
    // 创建训练样本
    if ( !imgReader.create( _posFilename, _negFilename, _cascadeParams.winSize ) )
    {
        cout &lt;&lt; "Image reader can not be created from -vec " &lt;&lt; _posFilename
                &lt;&lt; " and -bg " &lt;&lt; _negFilename &lt;&lt; "." &lt;&lt; endl;
        return false;
    }
    if ( !load( dirName ) )
    {
        cascadeParams = _cascadeParams;
        featureParams = CvFeatureParams::create(cascadeParams.featureType);
        featureParams-&gt;init(_featureParams);
        stageParams = makePtr&lt;CvCascadeBoostParams&gt;();
        *stageParams = _stageParams;
        featureEvaluator = CvFeatureEvaluator::create(cascadeParams.featureType);
        featureEvaluator-&gt;init( featureParams, numPos + numNeg, cascadeParams.winSize );
        stageClassifiers.reserve( numStages );
    }
    cout &lt;&lt; "PARAMETERS:" &lt;&lt; endl;
    cout &lt;&lt; "cascadeDirName: " &lt;&lt; _cascadeDirName &lt;&lt; endl;
    cout &lt;&lt; "vecFileName: " &lt;&lt; _posFilename &lt;&lt; endl;
    cout &lt;&lt; "bgFileName: " &lt;&lt; _negFilename &lt;&lt; endl;
    cout &lt;&lt; "numPos: " &lt;&lt; _numPos &lt;&lt; endl;
    cout &lt;&lt; "numNeg: " &lt;&lt; _numNeg &lt;&lt; endl;
    cout &lt;&lt; "numStages: " &lt;&lt; numStages &lt;&lt; endl;
    cout &lt;&lt; "precalcValBufSize[Mb] : " &lt;&lt; _precalcValBufSize &lt;&lt; endl;
    cout &lt;&lt; "precalcIdxBufSize[Mb] : " &lt;&lt; _precalcIdxBufSize &lt;&lt; endl;
    cascadeParams.printAttrs();
    stageParams-&gt;printAttrs();
    featureParams-&gt;printAttrs();

    int startNumStages = (int)stageClassifiers.size();
    if ( startNumStages &gt; 1 )
        cout &lt;&lt; endl &lt;&lt; "Stages 0-" &lt;&lt; startNumStages-1 &lt;&lt; " are loaded" &lt;&lt; endl;
    else if ( startNumStages == 1)
        cout &lt;&lt; endl &lt;&lt; "Stage 0 is loaded" &lt;&lt; endl;

    double requiredLeafFARate = pow( (double) stageParams-&gt;maxFalseAlarm, (double) numStages ) /
                                (double)stageParams-&gt;max_depth;
    double tempLeafFARate;

    for( int i = startNumStages; i &lt; numStages; i++ )
    {
        cout &lt;&lt; endl &lt;&lt; "===== TRAINING " &lt;&lt; i &lt;&lt; "-stage =====" &lt;&lt; endl;
        cout &lt;&lt; "&lt;BEGIN" &lt;&lt; endl;

        if ( !updateTrainingSet( tempLeafFARate ) )
        {
            cout &lt;&lt; "Train dataset for temp stage can not be filled. "
                "Branch training terminated." &lt;&lt; endl;
            break;
        }
        if( tempLeafFARate &lt;= requiredLeafFARate )
        {
            cout &lt;&lt; "Required leaf false alarm rate achieved. "
                 "Branch training terminated." &lt;&lt; endl;
            break;
        }

        Ptr&lt;CvCascadeBoost&gt; tempStage = makePtr&lt;CvCascadeBoost&gt;();
        bool isStageTrained = tempStage-&gt;train( featureEvaluator,
                                                curNumSamples, _precalcValBufSize, _precalcIdxBufSize,
                                                *stageParams );
        cout &lt;&lt; "END&gt;" &lt;&lt; endl;

        if(!isStageTrained)
            break;

        stageClassifiers.push_back( tempStage );

        // save params
        if( i == 0) // 如果是第一级，则保存训练的参数
        {
            std::string paramsFilename = dirName + CC_PARAMS_FILENAME;
            FileStorage fs( paramsFilename, FileStorage::WRITE);
            if ( !fs.isOpened() )
            {
                cout &lt;&lt; "Parameters can not be written, because file " &lt;&lt; paramsFilename
                        &lt;&lt; " can not be opened." &lt;&lt; endl;
                return false;
            }
            fs &lt;&lt; FileStorage::getDefaultObjectName(paramsFilename) &lt;&lt; "{";
            writeParams( fs );
            fs &lt;&lt; "}";
        }
        // save current stage
        char buf[10];
        sprintf(buf, "%s%d", "stage", i );
        string stageFilename = dirName + buf + ".xml";
        FileStorage fs( stageFilename, FileStorage::WRITE );
        if ( !fs.isOpened() )
        {
            cout &lt;&lt; "Current stage can not be written, because file " &lt;&lt; stageFilename
                    &lt;&lt; " can not be opened." &lt;&lt; endl;
            return false;
        }
        fs &lt;&lt; FileStorage::getDefaultObjectName(stageFilename) &lt;&lt; "{";
        tempStage-&gt;write( fs, Mat() ); // 将中间的每级的分类器写入到目录中
        fs &lt;&lt; "}";
    }

    if(stageClassifiers.size() == 0)
    {
        cout &lt;&lt; "Cascade classifier can't be trained. Check the used training parameters." &lt;&lt; endl;
        return false;
    }

    save( dirName + CC_CASCADE_FILENAME, baseFormatSave );

    return true;
}

// boostrap 正负训练样本
int CvCascadeClassifier::fillPassedSamples( int first, int count, bool isPositive, int64&amp; consumed )
{
    int getcount = 0;
    Mat img(cascadeParams.winSize, CV_8UC1);
    for( int i = first; i &lt; first + count; i++ )
    {
        for( ; ; )
        {
            bool isGetImg = isPositive ? imgReader.getPos( img ) :
                                           imgReader.getNeg( img );
            if( !isGetImg )
                return getcount;
            consumed++;

            featureEvaluator-&gt;setImage( img, isPositive ? 1 : 0, i );
            if( predict( i ) == 1.0F ) // 如果predict为人脸，则加到训练集当中，这里如果人脸图像被判断为负的话，则剔除这些样本，使得训练简单一些，但是这些样本加进去训练得到的分类器是比不加进去要强的，仍旧推荐使用
            {
                getcount++;
                break;
            }
        }
    }
    return getcount;
}
&lt;/code&gt;&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Sat, 05 Oct 2013 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2013-10-05:opencv_traincascade-dai-ma-yue-du-appstraincascadecascadeclassifiercpp.html</guid><category>Computer Vision</category><category>OpenCV</category></item><item><title>opencv_traincascade 代码阅读(ml/boost.cpp)</title><link>http://icylord.github.io/opencv_traincascade-dai-ma-yue-du-mlboostcpp.html</link><description>&lt;h1&gt;两个分支CART作为弱分类器太弱了 -____-!!!&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;
CvDTreeSplit*
CvBoostTree::find_split_cat_reg( CvDTreeNode* node, int vi, float init_quality, CvDTreeSplit* _split, uchar* _ext_buf )
{
    const double* weights = ensemble-&gt;get_subtree_weights()-&gt;data.db;
    int ci = data-&gt;get_var_type(vi);
    int n = node-&gt;sample_count;
    int mi = data-&gt;cat_count-&gt;data.i[ci];
    int base_size = (2*mi+3)*sizeof(double) + mi*sizeof(double*);
    cv::AutoBuffer&lt;uchar&gt; inn_buf(base_size);
    if( !_ext_buf )
        inn_buf.allocate(base_size + n*(2*sizeof(int) + sizeof(float)));
    uchar* base_buf = (uchar*)inn_buf;
    uchar* ext_buf = _ext_buf ? _ext_buf : base_buf + base_size;

    int* cat_labels_buf = (int*)ext_buf;
    const int* cat_labels = data-&gt;get_cat_var_data(node, vi, cat_labels_buf);
    float* responses_buf = (float*)(cat_labels_buf + n);
    int* sample_indices_buf = (int*)(responses_buf + n);
    const float* responses = data-&gt;get_ord_responses(node, responses_buf, sample_indices_buf);

    double* sum = (double*)cv::alignPtr(base_buf,sizeof(double)) + 1;
    double* counts = sum + mi + 1;
    double** sum_ptr = (double**)(counts + mi);
    double L = 0, R = 0, best_val = init_quality, lsum = 0, rsum = 0;
    int i, best_subset = -1, subset_i;

    for( i = -1; i &lt; mi; i++ ) // LBP对应 [0, 255]
        sum[i] = counts[i] = 0;

    // calculate sum response and weight of each category of the input var
    for( i = 0; i &lt; n; i++ )
    {
        int idx = ((cat_labels[i] == 65535) &amp;&amp; data-&gt;is_buf_16u) ? -1 : cat_labels[i];
        double w = weights[i]; // 样本的当前权重
        double s = sum[idx] + responses[i]*w; // 将样本的当前权重乘以类标(-1 or 1)累加到对应的idx里面，LBP对应 [0, 255]
        double nc = counts[idx] + w; // 将样本的权重累加
        sum[idx] = s;
        counts[idx] = nc;
    }

    // calculate average response in each category
    for( i = 0; i &lt; mi; i++ )
    {
        R += counts[i];
        rsum += sum[i];
        sum[i] = fabs(counts[i]) &gt; DBL_EPSILON ? sum[i]/counts[i] : 0; // 求出每个i里面的输出分数
        sum_ptr[i] = sum + i; //保存指针，用于根据sum的值进行排序
    }

    icvSortDblPtr( sum_ptr, mi, 0 );

    // revert back to unnormalized sums
    // (there should be a very little loss in accuracy)
    for( i = 0; i &lt; mi; i++ )
        sum[i] *= counts[i];

    // 求解CART回归树最优切分点代码
    for( subset_i = 0; subset_i &lt; mi-1; subset_i++ )
    {
        int idx = (int)(sum_ptr[subset_i] - sum); // 排序后第subset_i大的输出分数对应的sum下标
        double ni = counts[idx];

        if( ni &gt; FLT_EPSILON )
        {
            double s = sum[idx];
            lsum += s; L += ni;
            rsum -= s; R -= ni;

            if( L &gt; FLT_EPSILON &amp;&amp; R &gt; FLT_EPSILON )
            {
                double val = (lsum*lsum*R + rsum*rsum*L)/(L*R); //根据MBLBP论文Eq.2推出
                if( best_val &lt; val ) // 存在更优，则选择best_subset作为切分点
                {
                    best_val = val;
                    best_subset = subset_i;
                }
            }
        }
    }

    CvDTreeSplit* split = 0;
    if( best_subset &gt;= 0 )
    {
        split = _split ? _split : data-&gt;new_split_cat( 0, -1.0f);
        split-&gt;var_idx = vi;
        split-&gt;quality = (float)best_val;
        memset( split-&gt;subset, 0, (data-&gt;max_c_count + 31)/32 * sizeof(int));
        for( i = 0; i &lt;= best_subset; i++ ) // 以best_subset作为切分点，左边的送到左子树，右边的送到右子树
        {
            int idx = (int)(sum_ptr[i] - sum);
            split-&gt;subset[idx &gt;&gt; 5] |= 1 &lt;&lt; (idx &amp; 31);
        }
    }
    return split;
}
&lt;/code&gt;&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Fri, 04 Oct 2013 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2013-10-04:opencv_traincascade-dai-ma-yue-du-mlboostcpp.html</guid><category>Computer Vision</category><category>OpenCV</category></item><item><title>Install Numpy/Scipy with Intel MKL On MacOSX 10.8</title><link>http://icylord.github.io/install-numpyscipy-with-intel-mkl-on-macosx-108.html</link><description>&lt;h1&gt;First&lt;/h1&gt;
&lt;p&gt;Install Intel MKL(intel_cpp_comp_2013_mac)&lt;/p&gt;
&lt;p&gt;Download &lt;a href="http://sourceforge.net/projects/numpy/files/NumPy/"&gt;numpy&lt;/a&gt; and &lt;a href="http://sourceforge.net/projects/scipy/files/scipy/"&gt;scipy&lt;/a&gt; and unzip them.
&lt;pre&gt;&lt;code&gt;
unzip numpy-1.7.0.zip
unzip scipy-0.12.0.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Second&lt;/h1&gt;
&lt;p&gt;(1)modify numpy-1.7.0/numpy/distutils/site.cfg&lt;/p&gt;
&lt;p&gt;change line 143~146 to
&lt;pre&gt;&lt;code&gt;
library_dirs = /opt/intel/mkl/lib
include_dirs = /opt/intel/mkl/include
lapack_libs = mkl_lapack95
mkl_libs = mkl_rt
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(2)modify numpy-1.7.0/numpy/distutils/intelccompiler.py&lt;/p&gt;
&lt;p&gt;change line 37 to
&lt;pre&gt;&lt;code&gt;
self.cc_exe = 'icc -m64 -fPIC -O3 -g -fPIC -fp-model strict -fomit-frame-pointer -openmp -xhost -undefined dynamic_lookup -bundle -DMKL_ILP64' 
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(3) modify numpy-1.7.0/numpy/distutils/system_info.py&lt;/p&gt;
&lt;p&gt;change line 1448~1451 and add 
&lt;pre&gt;&lt;code&gt;
blas_mkl_info = get_info('blas_mkl')
        if blas_mkl_info:
            self.set_info(**blas_mkl_info)
            return
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;then change line 1360~1363 and add
&lt;pre&gt;&lt;code&gt;
lapack_mkl_info = get_info('lapack_mkl')
        if lapack_mkl_info:
            self.set_info(**lapack_mkl_info)
            return
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(4) compile numpy 
&lt;pre&gt;&lt;code&gt;
python setup.py config --compiler=intelem build_clib --compiler=intelem build_ext --compiler=intelem install
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Third&lt;/h1&gt;
&lt;p&gt;compile scipy
&lt;pre&gt;&lt;code&gt;
python setup.py config --compiler=intelem --fcompiler=intelem build_clib --compiler=intelem --fcompiler=intelem build_ext --compiler=intelem --fcompiler=intelem install
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Last&lt;/h1&gt;
&lt;p&gt;use this code to check the whether MKL is supported for numpy
&lt;pre&gt;&lt;code&gt;
import numpy as np &lt;br /&gt;
np.show_config()&lt;br /&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Tue, 10 Sep 2013 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2013-09-10:install-numpyscipy-with-intel-mkl-on-macosx-108.html</guid><category>Computer Vision</category><category>Python</category></item><item><title>SZU Face Detector Performance</title><link>http://icylord.github.io/szu-face-detector-performance.html</link><description>&lt;p&gt;Our new face detection algorithm(Shenzhen University Face Detector) reach &lt;strong&gt;state of the art&lt;/strong&gt;  on FDDB and AFW dataset.&lt;/p&gt;
&lt;p&gt;For FDDB result please refer to &lt;a href="http://vis-www.cs.umass.edu/fddb/results.html"&gt;FDDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For AFW result please refer to &lt;a href="http://www.ics.uci.edu/~xzhu/face"&gt;AFW&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/static/img/MV_FDDB_Disc_FPPI.png" height="480" width="640" alt="FDDB Result" /&gt;
&lt;img src="/static/img/MV_AFW_Disc_RP.png" height="480" width="640" alt="AFW Result" /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">icylord</dc:creator><pubDate>Tue, 10 Sep 2013 00:00:00 +0200</pubDate><guid>tag:icylord.github.io,2013-09-10:szu-face-detector-performance.html</guid><category>Computer Vision</category></item></channel></rss>