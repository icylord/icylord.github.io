<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>icylord's blog</title><link href="http://icylord.github.io/" rel="alternate"></link><link href="http://icylord.github.io/feeds/all.atom.xml" rel="self"></link><id>http://icylord.github.io/</id><updated>2013-09-10T00:00:00+02:00</updated><entry><title>Install Numpy/Scipy with Intel MKL On MacOSX 10.8</title><link href="http://icylord.github.io/install-numpyscipy-with-intel-mkl-on-macosx-108.html" rel="alternate"></link><updated>2013-09-10T00:00:00+02:00</updated><author><name>icylord</name></author><id>tag:icylord.github.io,2013-09-10:install-numpyscipy-with-intel-mkl-on-macosx-108.html</id><summary type="html">&lt;h1&gt;First&lt;/h1&gt;
&lt;p&gt;Install Intel MKL(intel_cpp_comp_2013_mac)&lt;/p&gt;
&lt;p&gt;Download &lt;a href="http://sourceforge.net/projects/numpy/files/NumPy/"&gt;numpy&lt;/a&gt; and &lt;a href="http://sourceforge.net/projects/scipy/files/scipy/"&gt;scipy&lt;/a&gt; and unzip them.
&lt;pre&gt;&lt;code&gt;
unzip numpy-1.7.0.zip
unzip scipy-0.12.0.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Second&lt;/h1&gt;
&lt;p&gt;(1)modify numpy-1.7.0/numpy/distutils/site.cfg&lt;/p&gt;
&lt;p&gt;change line 143~146 to
&lt;pre&gt;&lt;code&gt;
library_dirs = /opt/intel/mkl/lib
include_dirs = /opt/intel/mkl/include
lapack_libs = mkl_lapack95
mkl_libs = mkl_rt
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(2)modify numpy-1.7.0/numpy/distutils/intelccompiler.py&lt;/p&gt;
&lt;p&gt;change line 37 to
&lt;pre&gt;&lt;code&gt;
self.cc_exe = 'icc -m64 -fPIC -O3 -g -fPIC -fp-model strict -fomit-frame-pointer -openmp -xhost -undefined dynamic_lookup -bundle -DMKL_ILP64' 
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(3) modify numpy-1.7.0/numpy/distutils/system_info.py&lt;/p&gt;
&lt;p&gt;change line 1448~1451 and add 
&lt;pre&gt;&lt;code&gt;
blas_mkl_info = get_info('blas_mkl')
        if blas_mkl_info:
            self.set_info(**blas_mkl_info)
            return
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;then change line 1360~1363 and add
&lt;pre&gt;&lt;code&gt;
lapack_mkl_info = get_info('lapack_mkl')
        if lapack_mkl_info:
            self.set_info(**lapack_mkl_info)
            return
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(4) compile numpy 
&lt;pre&gt;&lt;code&gt;
python setup.py config --compiler=intelem build_clib --compiler=intelem build_ext --compiler=intelem install
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Third&lt;/h1&gt;
&lt;p&gt;compile scipy
&lt;pre&gt;&lt;code&gt;
python setup.py config --compiler=intelem --fcompiler=intelem build_clib --compiler=intelem --fcompiler=intelem build_ext --compiler=intelem --fcompiler=intelem install
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Last&lt;/h1&gt;
&lt;p&gt;use this code to check the whether MKL is supported for numpy
&lt;pre&gt;&lt;code&gt;
import numpy as np &lt;br /&gt;
np.show_config()&lt;br /&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;</summary><category term="Computer Vision"></category><category term="Python"></category></entry><entry><title>opencv_traincascade 代码阅读</title><link href="http://icylord.github.io/opencv_traincascade-dai-ma-yue-du.html" rel="alternate"></link><updated>2013-09-10T00:00:00+02:00</updated><author><name>icylord</name></author><id>tag:icylord.github.io,2013-09-10:opencv_traincascade-dai-ma-yue-du.html</id><summary type="html">&lt;pre&gt;&lt;code&gt;
CvDTreeSplit*
CvBoostTree::find_split_cat_reg( CvDTreeNode* node, int vi, float init_quality, CvDTreeSplit* _split, uchar* _ext_buf )
{
    const double* weights = ensemble-&gt;get_subtree_weights()-&gt;data.db;
    int ci = data-&gt;get_var_type(vi);
    int n = node-&gt;sample_count;
    int mi = data-&gt;cat_count-&gt;data.i[ci];
    int base_size = (2*mi+3)*sizeof(double) + mi*sizeof(double*);
    cv::AutoBuffer&lt;uchar&gt; inn_buf(base_size);
    if( !_ext_buf )
        inn_buf.allocate(base_size + n*(2*sizeof(int) + sizeof(float)));
    uchar* base_buf = (uchar*)inn_buf;
    uchar* ext_buf = _ext_buf ? _ext_buf : base_buf + base_size;

    int* cat_labels_buf = (int*)ext_buf;
    const int* cat_labels = data-&gt;get_cat_var_data(node, vi, cat_labels_buf);
    float* responses_buf = (float*)(cat_labels_buf + n);
    int* sample_indices_buf = (int*)(responses_buf + n);
    const float* responses = data-&gt;get_ord_responses(node, responses_buf, sample_indices_buf);

    double* sum = (double*)cv::alignPtr(base_buf,sizeof(double)) + 1;
    double* counts = sum + mi + 1;
    double** sum_ptr = (double**)(counts + mi);
    double L = 0, R = 0, best_val = init_quality, lsum = 0, rsum = 0;
    int i, best_subset = -1, subset_i;

    for( i = -1; i &lt; mi; i++ ) // LBP对应 [0, 255]
        sum[i] = counts[i] = 0;

    // calculate sum response and weight of each category of the input var
    for( i = 0; i &lt; n; i++ )
    {
        int idx = ((cat_labels[i] == 65535) &amp;&amp; data-&gt;is_buf_16u) ? -1 : cat_labels[i];
        double w = weights[i]; // 样本的当前权重
        double s = sum[idx] + responses[i]*w; // 将样本的当前权重乘以类标(-1 or 1)累加到对应的idx里面，LBP对应 [0, 255]
        double nc = counts[idx] + w; // 将样本的权重累加
        sum[idx] = s;
        counts[idx] = nc;
    }

    // calculate average response in each category
    for( i = 0; i &lt; mi; i++ )
    {
        R += counts[i];
        rsum += sum[i];
        sum[i] = fabs(counts[i]) &gt; DBL_EPSILON ? sum[i]/counts[i] : 0; // 求出每个i里面的输出分数
        sum_ptr[i] = sum + i; //保存指针，用于根据sum的值进行排序
    }

    icvSortDblPtr( sum_ptr, mi, 0 );

    // revert back to unnormalized sums
    // (there should be a very little loss in accuracy)
    for( i = 0; i &lt; mi; i++ )
        sum[i] *= counts[i];

    // 求解CART回归树最优切分点代码
    for( subset_i = 0; subset_i &lt; mi-1; subset_i++ )
    {
        int idx = (int)(sum_ptr[subset_i] - sum); // 排序后第subset_i大的输出分数对应的sum下标
        double ni = counts[idx];

        if( ni &gt; FLT_EPSILON )
        {
            double s = sum[idx];
            lsum += s; L += ni;
            rsum -= s; R -= ni;

            if( L &gt; FLT_EPSILON &amp;&amp; R &gt; FLT_EPSILON )
            {
                double val = (lsum*lsum*R + rsum*rsum*L)/(L*R); //根据MBLBP论文Eq.2推出
                if( best_val &lt; val ) // 存在更优，则选择best_subset作为切分点
                {
                    best_val = val;
                    best_subset = subset_i;
                }
            }
        }
    }

    CvDTreeSplit* split = 0;
    if( best_subset &gt;= 0 )
    {
        split = _split ? _split : data-&gt;new_split_cat( 0, -1.0f);
        split-&gt;var_idx = vi;
        split-&gt;quality = (float)best_val;
        memset( split-&gt;subset, 0, (data-&gt;max_c_count + 31)/32 * sizeof(int));
        for( i = 0; i &lt;= best_subset; i++ ) // 以best_subset作为切分点，左边的送到左子树，右边的送到右子树
        {
            int idx = (int)(sum_ptr[i] - sum);
            split-&gt;subset[idx &gt;&gt; 5] |= 1 &lt;&lt; (idx &amp; 31);
        }
    }
    return split;
}
&lt;/code&gt;&lt;/pre&gt;</summary><category term="Computer Vision"></category><category term="OpenCV"></category></entry><entry><title>SZU Face Detector Performance</title><link href="http://icylord.github.io/szu-face-detector-performance.html" rel="alternate"></link><updated>2013-09-10T00:00:00+02:00</updated><author><name>icylord</name></author><id>tag:icylord.github.io,2013-09-10:szu-face-detector-performance.html</id><summary type="html">&lt;p&gt;Our new face detection algorithm(Shenzhen University Face Detector) reach &lt;strong&gt;state of the art&lt;/strong&gt;  on FDDB and AFW dataset.&lt;/p&gt;
&lt;p&gt;For FDDB result please refer to &lt;a href="http://vis-www.cs.umass.edu/fddb/results.html"&gt;FDDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For AFW result please refer to &lt;a href="http://www.ics.uci.edu/~xzhu/face"&gt;AFW&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/static/img/MV_FDDB_Disc_FPPI.png" height="480" width="640" alt="FDDB Result" /&gt;
&lt;img src="/static/img/MV_AFW_Disc_RP.png" height="480" width="640" alt="AFW Result" /&gt;&lt;/p&gt;</summary><category term="Computer Vision"></category></entry></feed>