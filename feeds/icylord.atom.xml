<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>icylord's blog</title><link href="http://icylord.github.io/" rel="alternate"></link><link href="http://icylord.github.io/feeds/icylord.atom.xml" rel="self"></link><id>http://icylord.github.io/</id><updated>2014-07-01T00:00:00+02:00</updated><entry><title>Implememt virtual camera on Windows 7 using DirectShow</title><link href="http://icylord.github.io/implememt-virtual-camera-on-windows-7-using-directshow.html" rel="alternate"></link><updated>2014-07-01T00:00:00+02:00</updated><author><name>icylord</name></author><id>tag:icylord.github.io,2014-07-01:implememt-virtual-camera-on-windows-7-using-directshow.html</id><summary type="html">&lt;h2&gt;Windows7下使用Directshow实现虚拟摄像头&lt;/h2&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;近期碰到了个项目，破解了某个摄像头设备的视频数据流到PC的方法(Linux+RTSP Streaming -&amp;gt; PC -&amp;gt; Virtual Camera -&amp;gt; Skype/Link/QQ)，打算扔掉这个设备自带的驱动，自己写一个，需要在Windows平台下实现一个虚拟摄像头，使得Skype、QQ等聊天软件能够使用远端的Web Camera设备的视频数据作为输入端进行视频聊天，在网上搜刮了一番资料后，花了点时间将其实现了。近期有时间，就把整个实现方法和过程写下来方便以后回顾&lt;/p&gt;
&lt;p&gt;在进行之前首先需要知道什么是&lt;strong&gt;DirectShow&lt;/strong&gt;和&lt;strong&gt;DirectShow filter。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DirectShow&lt;/strong&gt;（摘自wikipedia）：DirectShow (sometimes abbreviated as DS or DShow), codename Quartz, is a multimedia framework and API produced by Microsoft for software developers to perform various operations with media files or streams. It is the replacement for Microsoft's earlier Video for Windows technology. &lt;strong&gt;Based on the Microsoft Windows Component Object Model (COM) framework, DirectShow provides a common interface for media across various programming languages, and is an extensible, filter-based framework that can render or record media files on demand at the request of the user or developer&lt;/strong&gt;. 也就是说，DirectShow为多媒体流的捕捉和回放提供了强而有力的支持。 通过DirectShow，我们可以很方便地从支持WDM驱动模型的采集卡上采集数据，并进行相应的后期处理乃至存储到文件当中。DirectShow是一种开放式的开发环境，我们可以根据自己的需求定制自己的组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DirectShow Filter&lt;/strong&gt;（摘自MSDN）：DirectShow provides a set of default filters in Windows. &lt;strong&gt;These filters support many data formats while providing a high degree of hardware independence&lt;/strong&gt;. An application can also register and install custom filters on the target system. DirectShow是基于模块化的，每个功能模块采取COM组件的方式，成为Filter。Filter是DirectShow的最基本的概念。DirectShow使用Filter Graph来管理Filter。Filter Graph是Filter的“容器”，而Filter是Filter Graph的最小功能模块。粗略地说，可以认为Filter是一个插件。 我们可以自定义实现Filter提供给Filter Graph来使用达到我们特殊的应用目的。&lt;/p&gt;
&lt;p&gt;DirectShow Filter包括&lt;strong&gt;Source Filter&lt;/strong&gt;、&lt;strong&gt;Transform Filter&lt;/strong&gt;和&lt;strong&gt;Render Filter&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Windows平台下，常见的聊天软件都是使用DirectShow获取摄像头并得到图像数据的，因此若要实现一个虚拟摄像头的功能，DirectShow是必不可少的。 至于DirectShow Filter，因为在需要实现的虚拟摄像头的功能中，图像的输入数据并不是直接由摄像头的提供方提供的驱动得到硬件设备数据，而是我们自己提供的数据，比如可以使本地的视频文件，或者是远端的图像数据。 微软提供了DirectShow Filter这种框架可以方便开发者进行自定义的数据输入的功能，当然，这只是DirectShow Filter能够做到的众多功能其中之一。 本文使用的是DirectShow Filter中的其中的Source Filter。&lt;/p&gt;
&lt;p&gt;下面给出一张实现了需要摄像头后，QQ选取摄像头设备的效果图，其中Virtual Camera为虚拟的设备：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/static/img/virtualcameraselection.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;实现虚拟摄像头需要进行如下步骤：&lt;/p&gt;
&lt;p&gt;（1）实现DLL注册函数，使得虚拟的设备能够在聊天软件或者VLC等软件在DShow列表中选取；&lt;/p&gt;
&lt;p&gt;（2）实现DirectShow Source Filter，包括得到图像输入数据，转换成标准的输出格式，提供给调用此Source filter的调用对象；&lt;/p&gt;
&lt;p&gt;（3）将生成的Dll文件注册到系统注册表中。&lt;/p&gt;
&lt;h3&gt;下面按照步骤逐一介绍实现方法&lt;/h3&gt;
&lt;h3&gt;第一部分&lt;/h3&gt;
&lt;p&gt;Filter是一个基于Dll的COM组件，一般Filter需要实现下面几个入口函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DllMain&lt;/li&gt;
&lt;li&gt;DllRegisterServer&lt;/li&gt;
&lt;li&gt;DllUnregisterServer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体可以参考DirectShow自带的Ball例子。需要注意的是，要使得设备能够被DirectShow选取到，则需要额外实现将Dll注册为CLSID_VideoInputDeviceCategory的函数。见下面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;STDAPI&lt;/span&gt; &lt;span class="nf"&gt;DllRegisterServer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;RegisterFilters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;STDAPI&lt;/span&gt; &lt;span class="nf"&gt;DllUnregisterServer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;RegisterFilters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;WINAPI&lt;/span&gt; &lt;span class="n"&gt;DllEntryPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HINSTANCE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ULONG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LPVOID&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;APIENTRY&lt;/span&gt; &lt;span class="nf"&gt;DllMain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HANDLE&lt;/span&gt; &lt;span class="n"&gt;hModule&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                      &lt;span class="n"&gt;DWORD&lt;/span&gt;  &lt;span class="n"&gt;dwReason&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                      &lt;span class="n"&gt;LPVOID&lt;/span&gt; &lt;span class="n"&gt;lpReserved&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;DllEntryPoint&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;HINSTANCE&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;hModule&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;dwReason&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lpReserved&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;STDAPI&lt;/span&gt; &lt;span class="nf"&gt;RegisterFilters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;bRegister&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NOERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;WCHAR&lt;/span&gt; &lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_PATH&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_PATH&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;ASSERT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g_hInst&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;GetModuleFileNameA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g_hInst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; 
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;AmHresultFromWin32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GetLastError&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;MultiByteToWideChar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CP_ACP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lstrlenA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;achTemp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
        &lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NUMELMS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CoInitialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bRegister&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// The AMovieDllRegisterServer2 function creates registry entries for every component in the g_Templates&lt;/span&gt;
        &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AMovieSetupRegisterServer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;g_wszName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;achFileName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;L&amp;quot;Both&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;L&amp;quot;InprocServer32&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUCCEEDED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;IFilterMapper2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pFM2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CoCreateInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_FilterMapper2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CLSCTX_INPROC_SERVER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;IID_IFilterMapper2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUCCEEDED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bRegister&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;IMoniker&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pMoniker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;RegisterFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;g_wszName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pMoniker&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;CLSID_VideoInputDeviceCategory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rf2FilterReg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;UnregisterFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;CLSID_VideoInputDeviceCategory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;// release interface&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;pFM2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Release&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUCCEEDED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;bRegister&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AMovieSetupUnregisterServer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLSID_VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;CoFreeUnusedLibraries&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;CoUninitialize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中CLSID_VirtualCamera为我们自己生成的GUID，每个COM组件使用一个唯一的GUID来标识，当创建一个COM组件的时候，都是首先通过该ID调用CoCreateInstance函数来创建对应的组件类工厂。我们可以使用自带软件GUID Generator生成，见图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/static/img/guid.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;生成后，将Result部分贴到源代码当中，并将name修改成我们自定义的名称，比如CLSID_VirtualCamera&lt;/p&gt;
&lt;p&gt;按照上述，将编译好的Dll进行注册，那么应该可以在聊天软件中的下拉列表看到我们虚拟出来的设备名称了。前提是已经实现了Source Filter，否则会编译不过的，呵呵。因为关键的Filter类还没有实现！&lt;/p&gt;
&lt;h3&gt;第二部分&lt;/h3&gt;
&lt;p&gt;Source Filter的实现
关键是需要实现继承CSource和CSourceStream这两个类，并实现相关的接口，列举如下：&lt;/p&gt;
&lt;p&gt;其中CSourceStream的子类必须继承IAMStreamConfig, IKsPropertySet这两个接口&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;VirtualCamera&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;CSource&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;

    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;CUnknown&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;WINAPI&lt;/span&gt; &lt;span class="n"&gt;CreateInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LPUNKNOWN&lt;/span&gt; &lt;span class="n"&gt;lpunk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;QueryInterface&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFIID&lt;/span&gt; &lt;span class="n"&gt;riid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;ppv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;IFilterGraph&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;GetGraph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;m_pGraph&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;

    &lt;span class="c1"&gt;// It is only allowed to to create these objects with CreateInstance&lt;/span&gt;
    &lt;span class="n"&gt;VirtualCamera&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LPUNKNOWN&lt;/span&gt; &lt;span class="n"&gt;lpunk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;Stop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;VirtualCameraStream&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;CSourceStream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IAMStreamConfig&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IKsPropertySet&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="nl"&gt;public:&lt;/span&gt;

    &lt;span class="n"&gt;VirtualCameraStream&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;VirtualCamera&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pParent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LPCWSTR&lt;/span&gt; &lt;span class="n"&gt;pPinName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;VirtualCameraStream&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// plots a ball into the supplied video frame&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;FillBuffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IMediaSample&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pms&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Ask for buffers of the size appropriate to the agreed media type&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;DecideBufferSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IMemAllocator&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pIMemAlloc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                             &lt;span class="n"&gt;ALLOCATOR_PROPERTIES&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pProperties&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Set the agreed media type, and set up the necessary ball parameters&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;SetMediaType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CMediaType&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pMediaType&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Because we calculate the ball there is no reason why we&lt;/span&gt;
    &lt;span class="c1"&gt;// can&amp;#39;t calculate it in any one of a set of formats...&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;CheckMediaType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CMediaType&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pMediaType&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;GetMediaType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;iPosition&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CMediaType&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pmt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Resets the stream time to zero&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;OnThreadCreate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Quality control notifications sent to us&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;Notify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IBaseFilter&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pSender&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Quality&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//  IUnknown&lt;/span&gt;
    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP&lt;/span&gt; &lt;span class="nf"&gt;QueryInterface&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFIID&lt;/span&gt; &lt;span class="n"&gt;riid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;ppv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ULONG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;AddRef&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GetOwner&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;AddRef&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;STDMETHODIMP_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ULONG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;Release&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GetOwner&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Release&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//  IAMStreamConfig&lt;/span&gt;
    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="n"&gt;SetFormat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AM_MEDIA_TYPE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pmt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;GetFormat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AM_MEDIA_TYPE&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;ppmt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;GetNumberOfCapabilities&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;piCount&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;piSize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;GetStreamCaps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;iIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AM_MEDIA_TYPE&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;pmt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BYTE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pSCC&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//  IKsPropertySet&lt;/span&gt;
    &lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFGUID&lt;/span&gt; &lt;span class="n"&gt;guidPropSet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;dwID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pPropData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbPropData&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;Get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFGUID&lt;/span&gt; &lt;span class="n"&gt;guidPropSet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;dwPropID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbInstanceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pPropData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;cbPropData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pcbReturned&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="n"&gt;STDMETHODCALLTYPE&lt;/span&gt; &lt;span class="nf"&gt;QuerySupported&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;REFGUID&lt;/span&gt; &lt;span class="n"&gt;guidPropSet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;dwPropID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pTypeSupport&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nl"&gt;private:&lt;/span&gt;
    &lt;span class="n"&gt;CCritSec&lt;/span&gt; &lt;span class="n"&gt;shared_state_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// Lock on shared_state_&lt;/span&gt;
    &lt;span class="n"&gt;CRefTime&lt;/span&gt; &lt;span class="n"&gt;sample_time_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// The time stamp for each sample&lt;/span&gt;
    &lt;span class="n"&gt;VirtualCamera&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;此部分持续更新&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;第三部分&lt;/h3&gt;
&lt;p&gt;实现完毕并且编译得到的Filter Dll需要注册到注册表中，才得到我们能够选取到的虚拟摄像头。 Filter本身是种COM组件，一般使用regsvr32.exe将其注册到注册表中。具体用法为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册：regsvr32.exe XXX.dll&lt;/li&gt;
&lt;li&gt;反注册： regsvr32.exe -u XXX.dll&lt;/li&gt;
&lt;li&gt;如果想取消注册完成的弹出提示窗口，可以再regsvr32.exe之后加上-s参数&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Directshow"></category></entry><entry><title>Recent work</title><link href="http://icylord.github.io/recent-work.html" rel="alternate"></link><updated>2014-06-10T00:00:00+02:00</updated><author><name>icylord</name></author><id>tag:icylord.github.io,2014-06-10:recent-work.html</id><summary type="html">&lt;p&gt;最近一个月打了不少鸡血，收获很大。
主要是在FFMPEG LIVE555 RTSP/RTP H.264 AAC WAV RtAudio Directshow Filter方面做了不少工作，实现了对
Camera Video和麦克风的 Streaming，同时在Windows上面写了类似Driver的东西，可以从聊天软件选取虚拟好的
Camera 和 Microphone设备接受远端的Video和Audio数据传输。迟点有时间再总结一下了。&lt;/p&gt;</summary><category term="Video"></category></entry><entry><title>Compile MYSQL++ in VS2010</title><link href="http://icylord.github.io/compile-mysql-in-vs2010.html" rel="alternate"></link><updated>2014-02-11T00:00:00+01:00</updated><author><name>icylord</name></author><id>tag:icylord.github.io,2014-02-11:compile-mysql-in-vs2010.html</id><summary type="html">&lt;p&gt;1、到http://tangentsoft.net/mysql++/下载mysql++-3.2.1 &lt;/p&gt;
&lt;p&gt;链接:&lt;a href="http://tangentsoft.net/mysql++/releases/mysql++-3.2.1.tar.gz"&gt;MYSQL++&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、解压缩文件&lt;/p&gt;
&lt;p&gt;3、进入mysql++-3.2.1\vc2008目录&lt;/p&gt;
&lt;p&gt;4、打开mysql++.
sln，让VS2010做自动转换，因为VS2010的工程配置目录改变了，因此VS2008的一些配置会丢失，因此需要手动添加mysql c connector的目录。同时只需要编译mysqlpp的lib，因此其他例子程序就编译了，所以下文只修改mysqlpp的工程目录。
5、默认的工程是编译x64的库，非常好编译，因此下文主要处理32位的情况。&lt;/p&gt;
&lt;p&gt;6、首先点击vs2010上方的x64，选择Configuration Manager，在active sulution 
platform选择new一个win32的配置，并复制x64的配置。然后把mysqlpp的platform改成win32。&lt;/p&gt;
&lt;p&gt;7、接着在工程中additional include directories添加mysql connector c的include路径。并且在preprocessor definitions 添加WIN32;_USRDLL;DLL_EXPORTS;_DEBUG;UNICODE;_UNICODE;MYSQLPP_MAKING_DLL;HAVE_MYSQL_SSL_SET;%(PreprocessorDefinitions)，这段宏定义可以在x64的相同位置找到。&lt;/p&gt;
&lt;p&gt;8、接着在mysqlpp工程中修改configuration type为 Dynamic Library；&lt;/p&gt;
&lt;p&gt;9、在mysqlpp工程中Linker-&amp;gt;General-&amp;gt;Additional Library Directories中添加C:\Program Files (x86)\MySQL\MySQL Connector C 6.1\lib，然后在Linker-&amp;gt;Input-&amp;gt;Additional Dependencies中添加libmysql.lib和wsock32.lib；&lt;/p&gt;
&lt;p&gt;10、最后一步需要修改工程的Runtime Library为MT的，进入C/C++-&amp;gt;Code Generation-&amp;gt;Runtime Library，修改为/MDd&lt;/p&gt;
&lt;p&gt;11、右键Solution Explorer点击mysqlpp点击build，即可生成mysqlpp.dll和mysqlpp.lib.&lt;/p&gt;
&lt;p&gt;12、Release版本的跟Debug类似，后续就不进行描述了。&lt;/p&gt;</summary><category term="Computer Vision"></category><category term="Python"></category></entry><entry><title>opencv_traincascade 代码阅读(apps/traincascade/boost.cpp)</title><link href="http://icylord.github.io/opencv_traincascade-dai-ma-yue-du-appstraincascadeboostcpp.html" rel="alternate"></link><updated>2013-10-05T00:00:00+02:00</updated><author><name>icylord</name></author><id>tag:icylord.github.io,2013-10-05:opencv_traincascade-dai-ma-yue-du-appstraincascadeboostcpp.html</id><summary type="html">&lt;pre&gt;&lt;code&gt;
//每个Stage的训练函数
bool CvCascadeBoost::train( const CvFeatureEvaluator* _featureEvaluator,
                           int _numSamples,
                           int _precalcValBufSize, int _precalcIdxBufSize,
                           const CvCascadeBoostParams&amp; _params )
{
    bool isTrained = false;
    CV_Assert( !data );
    clear();
    // 准备CART tree的训练数据，其中包括预先计算所有训练样本的特征值
    data = new CvCascadeBoostTrainData( _featureEvaluator, _numSamples,
                                        _precalcValBufSize, _precalcIdxBufSize, _params );
    CvMemStorage *storage = cvCreateMemStorage();
    weak = cvCreateSeq( 0, sizeof(CvSeq), sizeof(CvBoostTree*), storage );
    storage = 0;

    set_params( _params );
    if ( (_params.boost_type == LOGIT) || (_params.boost_type == GENTLE) )
        data-&gt;do_responses_copy();

    update_weights( 0 ); // 首次设置训练样本的权重

    cout &lt;&lt; "+----+---------+---------+" &lt;&lt; endl;
    cout &lt;&lt; "|  N |    HR   |    FA   |" &lt;&lt; endl;
    cout &lt;&lt; "+----+---------+---------+" &lt;&lt; endl;

    do
    {
        CvCascadeBoostTree* tree = new CvCascadeBoostTree;
        if( !tree-&gt;train( data, subsample_mask, this ) )
        {
            delete tree;
            break;
        }
        cvSeqPush( weak, &amp;tree ); // 添加弱分类器
        update_weights( tree ); // 更新训练样本的权重
        trim_weights(); // 根据trim_weights剔除一部分训练样本
        if( cvCountNonZero(subsample_mask) == 0 )
            break;
    }
    while( !isErrDesired() &amp;&amp; (weak-&gt;total &lt; params.weak_count) ); // false alarm值达到预期或者弱分类器数目达到最大值，则停止迭代

    if(weak-&gt;total &gt; 0)
    {
        data-&gt;is_classifier = true;
        data-&gt;free_train_data();
        isTrained = true;
    }
    else
        clear();

    return isTrained;
}

// 每一级的强分类器停止迭代判断函数
bool CvCascadeBoost::isErrDesired()
{
    int sCount = data-&gt;sample_count,
        numPos = 0, numNeg = 0, numFalse = 0, numPosTrue = 0;
    vector&lt;float&gt; eval(sCount); // 保存分类器输出值

    for( int i = 0; i &lt; sCount; i++ )
        if( ((CvCascadeBoostTrainData*)data)-&gt;featureEvaluator-&gt;getCls( i ) == 1.0F )
            eval[numPos++] = predict( i, true ); // 计算所有正样本的输出值
    icvSortFlt( &amp;eval[0], numPos, 0 ); // 对正样本的输出值进行排序
    int thresholdIdx = (int)((1.0F - minHitRate) * numPos); // 根据minHitRate找出阈值
    threshold = eval[ thresholdIdx ];
    numPosTrue = numPos - thresholdIdx;
    for( int i = thresholdIdx - 1; i &gt;= 0; i--)
        if ( abs( eval[i] - threshold) &lt; FLT_EPSILON )
            numPosTrue++;
    float hitRate = ((float) numPosTrue) / ((float) numPos);

    for( int i = 0; i &lt; sCount; i++ )
    {
        if( ((CvCascadeBoostTrainData*)data)-&gt;featureEvaluator-&gt;getCls( i ) == 0.0F )
        {
            numNeg++;
            if( predict( i ) ) // 根据上面得到的阈值组成一个强分类器用于统计false alarm的数目
                numFalse++;
        }
    }
    float falseAlarm = ((float) numFalse) / ((float) numNeg);

    cout &lt;&lt; "|"; cout.width(4); cout &lt;&lt; right &lt;&lt; weak-&gt;total;
    cout &lt;&lt; "|"; cout.width(9); cout &lt;&lt; right &lt;&lt; hitRate;
    cout &lt;&lt; "|"; cout.width(9); cout &lt;&lt; right &lt;&lt; falseAlarm;
    cout &lt;&lt; "|" &lt;&lt; endl;
    cout &lt;&lt; "+----+---------+---------+" &lt;&lt; endl;

    return falseAlarm &lt;= maxFalseAlarm; // 如果false alarm并未达标，则返回 false
}


&lt;/code&gt;&lt;/pre&gt;</summary><category term="Computer Vision"></category><category term="OpenCV"></category></entry><entry><title>opencv_traincascade 代码阅读(apps/traincascade/cascadeclassifier.cpp)</title><link href="http://icylord.github.io/opencv_traincascade-dai-ma-yue-du-appstraincascadecascadeclassifiercpp.html" rel="alternate"></link><updated>2013-10-05T00:00:00+02:00</updated><author><name>icylord</name></author><id>tag:icylord.github.io,2013-10-05:opencv_traincascade-dai-ma-yue-du-appstraincascadecascadeclassifiercpp.html</id><summary type="html">&lt;pre&gt;&lt;code&gt;
级联分类器训练函数
bool CvCascadeClassifier::train( const string _cascadeDirName,
                                const string _posFilename,
                                const string _negFilename,
                                int _numPos, int _numNeg,
                                int _precalcValBufSize, int _precalcIdxBufSize,
                                int _numStages,
                                const CvCascadeParams&amp; _cascadeParams,
                                const CvFeatureParams&amp; _featureParams,
                                const CvCascadeBoostParams&amp; _stageParams,
                                bool baseFormatSave )
{
    if( _cascadeDirName.empty() || _posFilename.empty() || _negFilename.empty() )
        CV_Error( CV_StsBadArg, "_cascadeDirName or _bgfileName or _vecFileName is NULL" );

    string dirName;
    if (_cascadeDirName.find_last_of("/\\") == (_cascadeDirName.length() - 1) )
        dirName = _cascadeDirName;
    else
        dirName = _cascadeDirName + '/';

    numPos = _numPos;
    numNeg = _numNeg;
    numStages = _numStages;
    // 创建训练样本
    if ( !imgReader.create( _posFilename, _negFilename, _cascadeParams.winSize ) )
    {
        cout &lt;&lt; "Image reader can not be created from -vec " &lt;&lt; _posFilename
                &lt;&lt; " and -bg " &lt;&lt; _negFilename &lt;&lt; "." &lt;&lt; endl;
        return false;
    }
    if ( !load( dirName ) )
    {
        cascadeParams = _cascadeParams;
        featureParams = CvFeatureParams::create(cascadeParams.featureType);
        featureParams-&gt;init(_featureParams);
        stageParams = makePtr&lt;CvCascadeBoostParams&gt;();
        *stageParams = _stageParams;
        featureEvaluator = CvFeatureEvaluator::create(cascadeParams.featureType);
        featureEvaluator-&gt;init( featureParams, numPos + numNeg, cascadeParams.winSize );
        stageClassifiers.reserve( numStages );
    }
    cout &lt;&lt; "PARAMETERS:" &lt;&lt; endl;
    cout &lt;&lt; "cascadeDirName: " &lt;&lt; _cascadeDirName &lt;&lt; endl;
    cout &lt;&lt; "vecFileName: " &lt;&lt; _posFilename &lt;&lt; endl;
    cout &lt;&lt; "bgFileName: " &lt;&lt; _negFilename &lt;&lt; endl;
    cout &lt;&lt; "numPos: " &lt;&lt; _numPos &lt;&lt; endl;
    cout &lt;&lt; "numNeg: " &lt;&lt; _numNeg &lt;&lt; endl;
    cout &lt;&lt; "numStages: " &lt;&lt; numStages &lt;&lt; endl;
    cout &lt;&lt; "precalcValBufSize[Mb] : " &lt;&lt; _precalcValBufSize &lt;&lt; endl;
    cout &lt;&lt; "precalcIdxBufSize[Mb] : " &lt;&lt; _precalcIdxBufSize &lt;&lt; endl;
    cascadeParams.printAttrs();
    stageParams-&gt;printAttrs();
    featureParams-&gt;printAttrs();

    int startNumStages = (int)stageClassifiers.size();
    if ( startNumStages &gt; 1 )
        cout &lt;&lt; endl &lt;&lt; "Stages 0-" &lt;&lt; startNumStages-1 &lt;&lt; " are loaded" &lt;&lt; endl;
    else if ( startNumStages == 1)
        cout &lt;&lt; endl &lt;&lt; "Stage 0 is loaded" &lt;&lt; endl;

    double requiredLeafFARate = pow( (double) stageParams-&gt;maxFalseAlarm, (double) numStages ) /
                                (double)stageParams-&gt;max_depth;
    double tempLeafFARate;

    for( int i = startNumStages; i &lt; numStages; i++ )
    {
        cout &lt;&lt; endl &lt;&lt; "===== TRAINING " &lt;&lt; i &lt;&lt; "-stage =====" &lt;&lt; endl;
        cout &lt;&lt; "&lt;BEGIN" &lt;&lt; endl;

        if ( !updateTrainingSet( tempLeafFARate ) )
        {
            cout &lt;&lt; "Train dataset for temp stage can not be filled. "
                "Branch training terminated." &lt;&lt; endl;
            break;
        }
        if( tempLeafFARate &lt;= requiredLeafFARate )
        {
            cout &lt;&lt; "Required leaf false alarm rate achieved. "
                 "Branch training terminated." &lt;&lt; endl;
            break;
        }

        Ptr&lt;CvCascadeBoost&gt; tempStage = makePtr&lt;CvCascadeBoost&gt;();
        bool isStageTrained = tempStage-&gt;train( featureEvaluator,
                                                curNumSamples, _precalcValBufSize, _precalcIdxBufSize,
                                                *stageParams );
        cout &lt;&lt; "END&gt;" &lt;&lt; endl;

        if(!isStageTrained)
            break;

        stageClassifiers.push_back( tempStage );

        // save params
        if( i == 0) // 如果是第一级，则保存训练的参数
        {
            std::string paramsFilename = dirName + CC_PARAMS_FILENAME;
            FileStorage fs( paramsFilename, FileStorage::WRITE);
            if ( !fs.isOpened() )
            {
                cout &lt;&lt; "Parameters can not be written, because file " &lt;&lt; paramsFilename
                        &lt;&lt; " can not be opened." &lt;&lt; endl;
                return false;
            }
            fs &lt;&lt; FileStorage::getDefaultObjectName(paramsFilename) &lt;&lt; "{";
            writeParams( fs );
            fs &lt;&lt; "}";
        }
        // save current stage
        char buf[10];
        sprintf(buf, "%s%d", "stage", i );
        string stageFilename = dirName + buf + ".xml";
        FileStorage fs( stageFilename, FileStorage::WRITE );
        if ( !fs.isOpened() )
        {
            cout &lt;&lt; "Current stage can not be written, because file " &lt;&lt; stageFilename
                    &lt;&lt; " can not be opened." &lt;&lt; endl;
            return false;
        }
        fs &lt;&lt; FileStorage::getDefaultObjectName(stageFilename) &lt;&lt; "{";
        tempStage-&gt;write( fs, Mat() ); // 将中间的每级的分类器写入到目录中
        fs &lt;&lt; "}";
    }

    if(stageClassifiers.size() == 0)
    {
        cout &lt;&lt; "Cascade classifier can't be trained. Check the used training parameters." &lt;&lt; endl;
        return false;
    }

    save( dirName + CC_CASCADE_FILENAME, baseFormatSave );

    return true;
}

// boostrap 正负训练样本
int CvCascadeClassifier::fillPassedSamples( int first, int count, bool isPositive, int64&amp; consumed )
{
    int getcount = 0;
    Mat img(cascadeParams.winSize, CV_8UC1);
    for( int i = first; i &lt; first + count; i++ )
    {
        for( ; ; )
        {
            bool isGetImg = isPositive ? imgReader.getPos( img ) :
                                           imgReader.getNeg( img );
            if( !isGetImg )
                return getcount;
            consumed++;

            featureEvaluator-&gt;setImage( img, isPositive ? 1 : 0, i );
            if( predict( i ) == 1.0F ) // 如果predict为人脸，则加到训练集当中，这里如果人脸图像被判断为负的话，则剔除这些样本，使得训练简单一些，但是这些样本加进去训练得到的分类器是比不加进去要强的，仍旧推荐使用
            {
                getcount++;
                break;
            }
        }
    }
    return getcount;
}
&lt;/code&gt;&lt;/pre&gt;</summary><category term="Computer Vision"></category><category term="OpenCV"></category></entry><entry><title>opencv_traincascade 代码阅读(ml/boost.cpp)</title><link href="http://icylord.github.io/opencv_traincascade-dai-ma-yue-du-mlboostcpp.html" rel="alternate"></link><updated>2013-10-04T00:00:00+02:00</updated><author><name>icylord</name></author><id>tag:icylord.github.io,2013-10-04:opencv_traincascade-dai-ma-yue-du-mlboostcpp.html</id><summary type="html">&lt;h1&gt;两个分支CART作为弱分类器太弱了 -____-!!!&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;
CvDTreeSplit*
CvBoostTree::find_split_cat_reg( CvDTreeNode* node, int vi, float init_quality, CvDTreeSplit* _split, uchar* _ext_buf )
{
    const double* weights = ensemble-&gt;get_subtree_weights()-&gt;data.db;
    int ci = data-&gt;get_var_type(vi);
    int n = node-&gt;sample_count;
    int mi = data-&gt;cat_count-&gt;data.i[ci];
    int base_size = (2*mi+3)*sizeof(double) + mi*sizeof(double*);
    cv::AutoBuffer&lt;uchar&gt; inn_buf(base_size);
    if( !_ext_buf )
        inn_buf.allocate(base_size + n*(2*sizeof(int) + sizeof(float)));
    uchar* base_buf = (uchar*)inn_buf;
    uchar* ext_buf = _ext_buf ? _ext_buf : base_buf + base_size;

    int* cat_labels_buf = (int*)ext_buf;
    const int* cat_labels = data-&gt;get_cat_var_data(node, vi, cat_labels_buf);
    float* responses_buf = (float*)(cat_labels_buf + n);
    int* sample_indices_buf = (int*)(responses_buf + n);
    const float* responses = data-&gt;get_ord_responses(node, responses_buf, sample_indices_buf);

    double* sum = (double*)cv::alignPtr(base_buf,sizeof(double)) + 1;
    double* counts = sum + mi + 1;
    double** sum_ptr = (double**)(counts + mi);
    double L = 0, R = 0, best_val = init_quality, lsum = 0, rsum = 0;
    int i, best_subset = -1, subset_i;

    for( i = -1; i &lt; mi; i++ ) // LBP对应 [0, 255]
        sum[i] = counts[i] = 0;

    // calculate sum response and weight of each category of the input var
    for( i = 0; i &lt; n; i++ )
    {
        int idx = ((cat_labels[i] == 65535) &amp;&amp; data-&gt;is_buf_16u) ? -1 : cat_labels[i];
        double w = weights[i]; // 样本的当前权重
        double s = sum[idx] + responses[i]*w; // 将样本的当前权重乘以类标(-1 or 1)累加到对应的idx里面，LBP对应 [0, 255]
        double nc = counts[idx] + w; // 将样本的权重累加
        sum[idx] = s;
        counts[idx] = nc;
    }

    // calculate average response in each category
    for( i = 0; i &lt; mi; i++ )
    {
        R += counts[i];
        rsum += sum[i];
        sum[i] = fabs(counts[i]) &gt; DBL_EPSILON ? sum[i]/counts[i] : 0; // 求出每个i里面的输出分数
        sum_ptr[i] = sum + i; //保存指针，用于根据sum的值进行排序
    }

    icvSortDblPtr( sum_ptr, mi, 0 );

    // revert back to unnormalized sums
    // (there should be a very little loss in accuracy)
    for( i = 0; i &lt; mi; i++ )
        sum[i] *= counts[i];

    // 求解CART回归树最优切分点代码
    for( subset_i = 0; subset_i &lt; mi-1; subset_i++ )
    {
        int idx = (int)(sum_ptr[subset_i] - sum); // 排序后第subset_i大的输出分数对应的sum下标
        double ni = counts[idx];

        if( ni &gt; FLT_EPSILON )
        {
            double s = sum[idx];
            lsum += s; L += ni;
            rsum -= s; R -= ni;

            if( L &gt; FLT_EPSILON &amp;&amp; R &gt; FLT_EPSILON )
            {
                double val = (lsum*lsum*R + rsum*rsum*L)/(L*R); //根据MBLBP论文Eq.2推出
                if( best_val &lt; val ) // 存在更优，则选择best_subset作为切分点
                {
                    best_val = val;
                    best_subset = subset_i;
                }
            }
        }
    }

    CvDTreeSplit* split = 0;
    if( best_subset &gt;= 0 )
    {
        split = _split ? _split : data-&gt;new_split_cat( 0, -1.0f);
        split-&gt;var_idx = vi;
        split-&gt;quality = (float)best_val;
        memset( split-&gt;subset, 0, (data-&gt;max_c_count + 31)/32 * sizeof(int));
        for( i = 0; i &lt;= best_subset; i++ ) // 以best_subset作为切分点，左边的送到左子树，右边的送到右子树
        {
            int idx = (int)(sum_ptr[i] - sum);
            split-&gt;subset[idx &gt;&gt; 5] |= 1 &lt;&lt; (idx &amp; 31);
        }
    }
    return split;
}
&lt;/code&gt;&lt;/pre&gt;</summary><category term="Computer Vision"></category><category term="OpenCV"></category></entry><entry><title>Install Numpy/Scipy with Intel MKL On MacOSX 10.8</title><link href="http://icylord.github.io/install-numpyscipy-with-intel-mkl-on-macosx-108.html" rel="alternate"></link><updated>2013-09-10T00:00:00+02:00</updated><author><name>icylord</name></author><id>tag:icylord.github.io,2013-09-10:install-numpyscipy-with-intel-mkl-on-macosx-108.html</id><summary type="html">&lt;h1&gt;First&lt;/h1&gt;
&lt;p&gt;Install Intel MKL(intel_cpp_comp_2013_mac)&lt;/p&gt;
&lt;p&gt;Download &lt;a href="http://sourceforge.net/projects/numpy/files/NumPy/"&gt;numpy&lt;/a&gt; and &lt;a href="http://sourceforge.net/projects/scipy/files/scipy/"&gt;scipy&lt;/a&gt; and unzip them.
&lt;pre&gt;&lt;code&gt;
unzip numpy-1.7.0.zip
unzip scipy-0.12.0.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Second&lt;/h1&gt;
&lt;p&gt;(1)modify numpy-1.7.0/numpy/distutils/site.cfg&lt;/p&gt;
&lt;p&gt;change line 143~146 to
&lt;pre&gt;&lt;code&gt;
library_dirs = /opt/intel/mkl/lib
include_dirs = /opt/intel/mkl/include
lapack_libs = mkl_lapack95
mkl_libs = mkl_rt
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(2)modify numpy-1.7.0/numpy/distutils/intelccompiler.py&lt;/p&gt;
&lt;p&gt;change line 37 to
&lt;pre&gt;&lt;code&gt;
self.cc_exe = 'icc -m64 -fPIC -O3 -g -fPIC -fp-model strict -fomit-frame-pointer -openmp -xhost -undefined dynamic_lookup -bundle -DMKL_ILP64' 
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(3) modify numpy-1.7.0/numpy/distutils/system_info.py&lt;/p&gt;
&lt;p&gt;change line 1448~1451 and add 
&lt;pre&gt;&lt;code&gt;
blas_mkl_info = get_info('blas_mkl')
        if blas_mkl_info:
            self.set_info(**blas_mkl_info)
            return
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;then change line 1360~1363 and add
&lt;pre&gt;&lt;code&gt;
lapack_mkl_info = get_info('lapack_mkl')
        if lapack_mkl_info:
            self.set_info(**lapack_mkl_info)
            return
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;(4) compile numpy 
&lt;pre&gt;&lt;code&gt;
python setup.py config --compiler=intelem build_clib --compiler=intelem build_ext --compiler=intelem install
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Third&lt;/h1&gt;
&lt;p&gt;compile scipy
&lt;pre&gt;&lt;code&gt;
python setup.py config --compiler=intelem --fcompiler=intelem build_clib --compiler=intelem --fcompiler=intelem build_ext --compiler=intelem --fcompiler=intelem install
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h1&gt;Last&lt;/h1&gt;
&lt;p&gt;use this code to check the whether MKL is supported for numpy
&lt;pre&gt;&lt;code&gt;
import numpy as np &lt;br /&gt;
np.show_config()&lt;br /&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;</summary><category term="Computer Vision"></category><category term="Python"></category></entry><entry><title>SZU Face Detector Performance</title><link href="http://icylord.github.io/szu-face-detector-performance.html" rel="alternate"></link><updated>2013-09-10T00:00:00+02:00</updated><author><name>icylord</name></author><id>tag:icylord.github.io,2013-09-10:szu-face-detector-performance.html</id><summary type="html">&lt;p&gt;Our new face detection algorithm(Shenzhen University Face Detector) reach &lt;strong&gt;state of the art&lt;/strong&gt;  on FDDB and AFW dataset.&lt;/p&gt;
&lt;p&gt;For FDDB result please refer to &lt;a href="http://vis-www.cs.umass.edu/fddb/results.html"&gt;FDDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For AFW result please refer to &lt;a href="http://www.ics.uci.edu/~xzhu/face"&gt;AFW&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/static/img/MV_FDDB_Disc_FPPI.png" height="480" width="640" alt="FDDB Result" /&gt;
&lt;img src="/static/img/MV_AFW_Disc_RP.png" height="480" width="640" alt="AFW Result" /&gt;&lt;/p&gt;</summary><category term="Computer Vision"></category></entry></feed>